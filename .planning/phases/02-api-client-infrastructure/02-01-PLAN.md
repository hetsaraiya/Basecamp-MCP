---
phase: 02-api-client-infrastructure
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/client/types.ts
  - src/client/rate-limit.ts
  - src/client/BasecampClient.ts
autonomous: true
requirements:
  - NFR-1.1
  - NFR-1.2
  - NFR-1.3
  - NFR-5.1
  - NFR-5.2
  - NFR-5.3

must_haves:
  truths:
    - "A BasecampClient instantiated with { accessToken, accountId } can dispatch a GET request to any Basecamp URL and return the parsed JSON"
    - "A 429 response from Basecamp causes the client to read Retry-After, wait that duration, and retry — the caller never receives a 429 error"
    - "When Retry-After is absent, exponential backoff with jitter is applied (base 1s, max 30s)"
    - "Concurrent in-flight requests per client instance are capped at 5 — a 6th request queues until a slot frees"
    - "Calling any non-GET method (POST, PUT, PATCH, DELETE) throws a ReadOnlyError before any HTTP request is made"
    - "account_id is taken only from the constructor argument — no method accepts it as a parameter"
    - "One BasecampClient instance uses exactly one accessToken — no cross-user data is possible through a single instance"
  artifacts:
    - path: "src/client/types.ts"
      provides: "Shared TypeScript interfaces for client credentials, request options, and error types"
      exports:
        - BasecampCredentials
        - ReadOnlyError
        - RateLimitError
    - path: "src/client/rate-limit.ts"
      provides: "withRateLimit() wrapper and exponential backoff logic"
      exports:
        - withRateLimit
        - computeBackoffDelay
    - path: "src/client/BasecampClient.ts"
      provides: "Core got v14 instance, read-only guard, concurrent request cap"
      exports:
        - BasecampClient
      min_lines: 60
  key_links:
    - from: "src/client/BasecampClient.ts"
      to: "src/client/rate-limit.ts"
      via: "withRateLimit wraps every got request"
      pattern: "withRateLimit"
    - from: "src/client/BasecampClient.ts"
      to: "got instance"
      via: "got.extend() with beforeRequest hook enforcing GET-only"
      pattern: "beforeRequest.*method.*GET"
    - from: "src/client/rate-limit.ts"
      to: "Retry-After header"
      via: "response hook reads header before requeue"
      pattern: "Retry-After|retry-after"
---

<objective>
Create the core HTTP client: a `got` v14 instance wrapped in a `BasecampClient` class that enforces read-only access, caps concurrent requests, and handles Basecamp's 429 rate limit responses with Retry-After inspection and exponential-backoff-with-jitter fallback.

Purpose: MCP tools need a reliable, safe HTTP substrate that handles Basecamp's rate limit policies automatically. Without this layer, any tool that makes multiple calls during a fanout (e.g., fetching todos across multiple lists) will hit 429 bursts and crash the tool call. Building this as a tested layer before tools are wired eliminates an entire class of runtime failures.

Output: `src/client/types.ts`, `src/client/rate-limit.ts`, `src/client/BasecampClient.ts` — importable, fully typed, ready for Plan 02-02 to add content methods on top.
</objective>

<execution_context>
@/home/het/.claude/get-shit-done/workflows/execute-plan.md
@/home/het/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Shared types and interfaces</name>
  <files>src/client/types.ts</files>
  <action>
Create `src/client/types.ts` with the following exports:

```typescript
// Credentials passed to BasecampClient constructor — sourced from Phase 1's TokenStore
export interface BasecampCredentials {
  accessToken: string;
  accountId: string; // always from TokenStore, never from user input (NFR-5.2)
}

// Thrown when a non-GET method is attempted (NFR-5.1)
export class ReadOnlyError extends Error {
  constructor(method: string) {
    super(`BasecampClient is read-only in v1. Blocked method: ${method}`);
    this.name = 'ReadOnlyError';
  }
}

// Thrown when rate limit retries are exhausted (not thrown during normal retry — only after max attempts)
export class RateLimitError extends Error {
  readonly retryAfterMs: number;
  constructor(retryAfterMs: number) {
    super(`Basecamp rate limit exceeded. Retry after ${retryAfterMs}ms`);
    this.name = 'RateLimitError';
    this.retryAfterMs = retryAfterMs;
  }
}

// Request options for internal use
export interface BasecampRequestOptions {
  searchParams?: Record<string, string | number>;
}
```

This file has no runtime dependencies — pure TypeScript types and error classes.
  </action>
  <verify>Run `npx tsc --noEmit` (or `npx tsc -p tsconfig.json --noEmit`) — no type errors on types.ts.</verify>
  <done>File exists with all 4 exports. TypeScript compilation reports no errors on this file.</done>
</task>

<task type="auto">
  <name>Task 2: Rate-limit wrapper with Retry-After and exponential backoff</name>
  <files>src/client/rate-limit.ts</files>
  <action>
Create `src/client/rate-limit.ts` implementing two exports:

**`computeBackoffDelay(attempt: number): number`**
- Returns milliseconds to wait before retrying when Retry-After is absent (NFR-1.2)
- Formula: `Math.min(1000 * 2 ** attempt + Math.random() * 1000, 30_000)`
- attempt=0 → ~1-2s, attempt=1 → ~2-3s, attempt=2 → ~4-5s, capped at 30s
- Pure function — no side effects, easily testable

**`withRateLimit<T>(fn: () => Promise<T>, maxAttempts = 4): Promise<T>`**
- Calls `fn()` and catches HTTP 429 responses (NFR-1.1)
- On 429: reads `Retry-After` header from the error response
  - `got` throws `HTTPError` on 4xx — access via `error.response.headers['retry-after']`
  - If header is a number string (seconds): wait `parseInt(retryAfter, 10) * 1000` ms
  - If header is an HTTP-date string: wait `new Date(retryAfter).getTime() - Date.now()` ms
  - If header absent: use `computeBackoffDelay(attempt)` (NFR-1.2)
- After waiting, recurse with `attempt + 1`
- If `attempt >= maxAttempts`, throw `RateLimitError` with the final wait duration
- All other errors re-throw immediately (do not retry non-429 errors)

Implementation pattern:
```typescript
import { RateLimitError } from './types.js';
import type { HTTPError } from 'got';

export function computeBackoffDelay(attempt: number): number {
  return Math.min(1000 * Math.pow(2, attempt) + Math.random() * 1000, 30_000);
}

export async function withRateLimit<T>(
  fn: () => Promise<T>,
  attempt = 0,
  maxAttempts = 4
): Promise<T> {
  try {
    return await fn();
  } catch (error) {
    if (isHTTPError(error) && error.response.statusCode === 429) {
      if (attempt >= maxAttempts) {
        throw new RateLimitError(computeBackoffDelay(attempt));
      }
      const retryAfter = error.response.headers['retry-after'];
      const waitMs = parseRetryAfter(retryAfter) ?? computeBackoffDelay(attempt);
      await sleep(waitMs);
      return withRateLimit(fn, attempt + 1, maxAttempts);
    }
    throw error;
  }
}
```

Add `isHTTPError`, `parseRetryAfter`, and `sleep` as internal helpers. Use `import type { HTTPError } from 'got'` for the type check — detect with `'response' in error && 'statusCode' in (error as any).response`.

Note: `got` v14 is ESM-only. All imports must use `.js` extensions in the source (TypeScript resolves these to `.ts` during compilation with `"moduleResolution": "bundler"` or `"node16"`).
  </action>
  <verify>
1. Run `npx tsc --noEmit` — no type errors.
2. Write an inline smoke test (or use node --input-type=module) that calls `withRateLimit` with a mock that throws a fake 429 twice then succeeds — confirm it resolves on the third call without throwing.
  </verify>
  <done>`computeBackoffDelay` is a pure function returning increasing values. `withRateLimit` retries on 429 with Retry-After inspection and backoff fallback. TypeScript compilation clean.</done>
</task>

<task type="auto">
  <name>Task 3: BasecampClient core — got instance, concurrent cap, read-only guard</name>
  <files>src/client/BasecampClient.ts</files>
  <action>
Create `src/client/BasecampClient.ts` as the core HTTP client class.

**Constructor signature:**
```typescript
constructor(credentials: BasecampCredentials)
```
- Stores `credentials.accessToken` and `credentials.accountId` as private readonly fields
- Per-user token isolation: each instance owns exactly one token (NFR-5.3)
- `accountId` is never exposed via any public method parameter — only used internally to build URLs (NFR-5.2)

**Internal got instance:**
Create a `got` instance via `got.extend()` with these options:
```typescript
const instance = got.extend({
  prefixUrl: `https://3.basecampapi.com/${this.accountId}`,
  headers: {
    'Authorization': `Bearer ${this.accessToken}`,
    'User-Agent': 'Basecamp MCP Server (contact@openxcell.com)',
    'Accept': 'application/json',
  },
  responseType: 'json',
  timeout: { request: 30_000 },
});
```

**Read-only enforcement (NFR-5.1):**
Add a `beforeRequest` hook that checks `options.method` and throws `ReadOnlyError` for any method other than `'GET'`. The hook fires before any network request:
```typescript
hooks: {
  beforeRequest: [
    (options) => {
      if (options.method !== 'GET') {
        throw new ReadOnlyError(options.method ?? 'UNKNOWN');
      }
    },
  ],
},
```

**Concurrent request cap (NFR-1.3):**
Implement a simple semaphore (max 5 concurrent requests) using a counter + pending queue:
```typescript
private readonly maxConcurrent = 5;
private inFlight = 0;
private readonly queue: Array<() => void> = [];

private async acquire(): Promise<void> {
  if (this.inFlight < this.maxConcurrent) {
    this.inFlight++;
    return;
  }
  return new Promise((resolve) => this.queue.push(resolve));
}

private release(): void {
  const next = this.queue.shift();
  if (next) {
    next();
  } else {
    this.inFlight--;
  }
}
```

**Public `get()` method:**
```typescript
async get<T = unknown>(path: string, options?: BasecampRequestOptions): Promise<T>
```
- Calls `acquire()` before request, `release()` in finally block
- Wraps the got call in `withRateLimit(() => this.instance.get(path, { searchParams: options?.searchParams }).json<T>())`
- Returns parsed JSON as `T`
- `path` is relative to `prefixUrl` (e.g., `'projects.json'`, not the full URL)

**Also export a typed response accessor for raw got Response (needed by Plan 02-02 for Link header parsing):**
```typescript
async getRaw(path: string, options?: BasecampRequestOptions): Promise<import('got').Response<unknown>>
```
- Same acquire/release/rate-limit pattern but returns the full Response object (not `.json()`)
- Plan 02-02's `paginate()` needs the `link` response header

Check that `got` v14 is already in `package.json`. If not, note that `npm install got@14` is needed — do NOT add it silently; run `npm install got@14` as part of this task.
  </action>
  <verify>
1. Run `npx tsc --noEmit` — zero errors across all three files.
2. Create a throwaway script `scripts/test-client.ts` (or run inline) that:
   - Instantiates `new BasecampClient({ accessToken: 'test', accountId: '123' })`
   - Calls `client.get('projects.json')` — it will 401 with a fake token, which is fine; confirms the got instance fires
   - Attempts `(client as any).instance.post('x')` — should throw `ReadOnlyError` via the hook
3. Delete the throwaway script after verifying.
  </verify>
  <done>
- `BasecampClient` constructs without error
- `get()` and `getRaw()` methods exist and are typed
- Attempting a POST through the internal instance throws `ReadOnlyError`
- Concurrent cap semaphore logic is in place (inFlight counter + queue)
- TypeScript compilation clean with no `any` warnings
  </done>
</task>

</tasks>

<verification>
Run `npx tsc --noEmit` from the project root — must report zero errors.

Confirm the three files exist:
- `src/client/types.ts` — exports `BasecampCredentials`, `ReadOnlyError`, `RateLimitError`, `BasecampRequestOptions`
- `src/client/rate-limit.ts` — exports `computeBackoffDelay`, `withRateLimit`
- `src/client/BasecampClient.ts` — exports `BasecampClient` with `get()` and `getRaw()` methods

Spot-check read-only guard: instantiate the client and call an internal POST — must throw `ReadOnlyError` before any network activity.
</verification>

<success_criteria>
1. TypeScript compiles cleanly across all three client files
2. `withRateLimit` retries on 429 using Retry-After header value, falls back to exponential backoff with jitter when header is absent
3. `BasecampClient.get()` wraps every request in the rate-limit wrapper
4. Any non-GET attempt throws `ReadOnlyError` at the hook layer — no HTTP request is made
5. Concurrent in-flight cap is 5 — a 6th call waits in queue until a slot frees
6. `account_id` is never accepted as a method parameter — only as a constructor argument
7. Each `BasecampClient` instance is bound to exactly one `accessToken`
</success_criteria>

<output>
After completion, create `.planning/phases/02-api-client-infrastructure/02-01-SUMMARY.md` following the summary template at `@/home/het/.claude/get-shit-done/templates/summary.md`.

Key items to record in the summary:
- Exact exports from each file (for Plan 02-02 to import correctly)
- The `getRaw()` method signature (Plan 02-02 needs it for Link header access)
- Any decisions made about got v14 import style (ESM, `.js` extensions)
- Whether `got` was already in package.json or was added during this plan
</output>
