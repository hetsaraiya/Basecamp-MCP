---
phase: 02-api-client-infrastructure
plan: "02"
type: execute
wave: 2
depends_on:
  - "02-01"
files_modified:
  - src/client/paginate.ts
  - src/client/html-to-markdown.ts
  - src/client/schemas/index.ts
  - src/client/schemas/project.ts
  - src/client/schemas/message.ts
  - src/client/schemas/todo.ts
  - src/client/schemas/document.ts
  - src/client/schemas/campfire.ts
  - src/client/schemas/attachment.ts
  - src/client/BasecampClient.ts
autonomous: true
requirements:
  - NFR-2.1
  - NFR-2.2
  - NFR-2.3
  - NFR-3.1
  - NFR-3.2
  - NFR-3.3
  - NFR-4.1
  - NFR-4.2
  - NFR-4.3
  - NFR-4.4

must_haves:
  truths:
    - "A list call to any of the 6 content endpoints returns { items, has_more, next_page } — never a raw Basecamp JSON array"
    - "When a Basecamp response has a Link header with rel=next, has_more is true and next_page is the page number extracted from the URL"
    - "All rich-text content fields are markdown strings — no HTML angle brackets remain in any returned item"
    - "bc-attachment tags become [Attachment: filename (content-type)], mention tags become [@Name], bc-gallery tags become [Gallery]"
    - "List responses are capped at 100 items — items beyond 100 are dropped and has_more is forced true"
    - "Total serialized response payload per call does not exceed 50KB — items are truncated from the end if the limit is exceeded"
    - "Document list items contain only the first 500 chars of content — full content only via get_document"
    - "Attachment responses never include binary content — only metadata fields are returned"
  artifacts:
    - path: "src/client/paginate.ts"
      provides: "paginate() function that follows Link headers and returns PaginatedResult envelope"
      exports:
        - paginate
        - PaginatedResult
    - path: "src/client/html-to-markdown.ts"
      provides: "htmlToMarkdown() converting HTML including Basecamp-specific tags to markdown"
      exports:
        - htmlToMarkdown
    - path: "src/client/schemas/project.ts"
      provides: "Zod schema for normalized Project response"
      exports:
        - ProjectSchema
        - Project
    - path: "src/client/schemas/message.ts"
      provides: "Zod schema for normalized Message response"
      exports:
        - MessageSchema
        - Message
    - path: "src/client/schemas/todo.ts"
      provides: "Zod schema for normalized Todo and TodoList responses"
      exports:
        - TodoSchema
        - TodoListSchema
        - Todo
        - TodoList
    - path: "src/client/schemas/document.ts"
      provides: "Zod schema for normalized Document response (with truncated content for list)"
      exports:
        - DocumentSchema
        - DocumentSummarySchema
        - Document
        - DocumentSummary
    - path: "src/client/schemas/campfire.ts"
      provides: "Zod schema for normalized CampfireLine response"
      exports:
        - CampfireLineSchema
        - CampfireLine
    - path: "src/client/schemas/attachment.ts"
      provides: "Zod schema for normalized Attachment response (metadata only)"
      exports:
        - AttachmentSchema
        - Attachment
    - path: "src/client/schemas/index.ts"
      provides: "Re-exports all schemas and types"
    - path: "src/client/BasecampClient.ts"
      provides: "Extended with 6 content-type endpoint methods"
      min_lines: 150
  key_links:
    - from: "src/client/BasecampClient.ts"
      to: "src/client/paginate.ts"
      via: "All list methods call paginate() which uses client.getRaw()"
      pattern: "paginate\\("
    - from: "src/client/paginate.ts"
      to: "Link header"
      via: "parseLinkHeader() reads response.headers.link"
      pattern: "link.*rel.*next|rel.*next.*link"
    - from: "src/client/BasecampClient.ts"
      to: "src/client/html-to-markdown.ts"
      via: "htmlToMarkdown() called on every rich-text field before schema parse"
      pattern: "htmlToMarkdown"
    - from: "src/client/BasecampClient.ts"
      to: "src/client/schemas/"
      via: "zod .parse() validates and shapes every response item"
      pattern: "Schema\\.parse\\("
---

<objective>
Build the content layer on top of the HTTP core from Plan 02-01: a `paginate()` function that follows Link-header pagination, an `htmlToMarkdown()` converter handling Basecamp-specific tags, zod schemas normalizing all 6 content types, and endpoint methods added to `BasecampClient` — enforcing item caps, payload size limits, and document truncation.

Purpose: MCP tools must receive typed, normalized data — not raw Basecamp JSON with HTML strings. This layer is the contract between the Basecamp API and the tool layer. If any HTML leaks through or pagination is silently truncated, every downstream tool silently misbehaves. Building it in isolation (separate plan) lets us verify the transformation pipeline independently before tools wire into it.

Output: `paginate.ts`, `html-to-markdown.ts`, `schemas/` directory with 6 content-type schemas, and `BasecampClient.ts` extended with all 6 endpoint methods returning `PaginatedResult<T>`.
</objective>

<execution_context>
@/home/het/.claude/get-shit-done/workflows/execute-plan.md
@/home/het/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-api-client-infrastructure/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pagination envelope and HTML-to-markdown pipeline</name>
  <files>
    src/client/paginate.ts
    src/client/html-to-markdown.ts
  </files>
  <action>
**File 1: `src/client/paginate.ts`**

Export the `PaginatedResult<T>` interface and `paginate()` function:

```typescript
export interface PaginatedResult<T> {
  items: T[];
  has_more: boolean;
  next_page: number | null;
}
```

`paginate<T>()` signature:
```typescript
export async function paginate<T>(
  client: { getRaw(path: string, opts?: { searchParams?: Record<string, string | number> }): Promise<import('got').Response<unknown>> },
  path: string,
  page = 1,
  transform: (raw: unknown) => T
): Promise<PaginatedResult<T>>
```

Implementation steps:
1. Call `client.getRaw(path, { searchParams: { page } })` to get the full response with headers (NFR-2.3)
2. Cast response body as `unknown[]` (Basecamp list endpoints always return arrays)
3. **Cap at 100 items (NFR-4.1):** `const capped = rawArray.slice(0, 100)`
4. Transform each item: `const items = capped.map(transform)`
5. **50KB payload cap (NFR-4.2):** Serialize `items` to JSON, measure byte length. If `Buffer.byteLength(JSON.stringify(items))` exceeds 51_200, drop items from the end until under the limit (binary search or pop loop). Set `has_more = true` if items were dropped.
6. **Parse Link header (NFR-2.1):** Read `response.headers['link']` (may be string or string[]). Extract the `rel="next"` URL using regex: `/<([^>]+)>;\s*rel="next"/`. If found, extract `page=(\d+)` from the URL query string → `next_page`. Else `next_page = null`.
7. **has_more (NFR-2.2):** `true` if Link header had `rel="next"` OR items were dropped for size, `false` otherwise.
8. Return `{ items, has_more, next_page }`.

**File 2: `src/client/html-to-markdown.ts`**

Export `htmlToMarkdown(html: string): string`.

Use the `node-html-parser` package (lightweight, no DOM, ESM-compatible — install with `npm install node-html-parser` if not in package.json). Do NOT use `turndown` or `marked` — they don't handle Basecamp's custom tags natively and add complexity.

Conversion rules (in order — apply in a single parse pass):

Standard HTML → Markdown (NFR-3.1):
- `<strong>`, `<b>` → `**text**`
- `<em>`, `<i>` → `*text*`
- `<a href="url">text</a>` → `[text](url)`
- `<h1>` → `# text`
- `<h2>` → `## text`
- `<h3>` → `### text`
- `<ul><li>` → `- item` (one per line)
- `<ol><li>` → `1. item` (sequential numbering)
- `<p>` → text + `\n\n`
- `<br>` → `\n`
- `<code>` → `` `text` ``
- `<pre>` → ` ```\ntext\n``` `
- `<blockquote>` → `> text`
- `<hr>` → `---`
- Strip all other unknown tags (keep inner text)

Basecamp-specific tags (NFR-3.2):
- `<bc-attachment>`: Read `filename` attribute and `content-type` attribute → `[Attachment: {filename} ({content-type})]`. If attributes missing, fall back to `[Attachment]`.
- `<mention>`: Read the element's text content (the person's name) → `[@{name}]`
- `<bc-gallery>`: → `[Gallery]` (no attributes needed)

Safety (NFR-3.3):
- After conversion, assert no `<` or `>` characters remain by stripping any residual HTML: run a final regex replace `/<[^>]+>/g` → `''` on the output. This is a safety net — the parse pass should handle everything.

Edge cases:
- Empty string input → return `''`
- Null/undefined input → return `''` (use `html ?? ''`)
- Nested tags: rely on node-html-parser's tree traversal (use `.innerText` for text-only fallback when needed)

Export structure:
```typescript
export function htmlToMarkdown(html: string | null | undefined): string
```
  </action>
  <verify>
1. Run `npx tsc --noEmit` — no errors on these two files.
2. Run inline tests for `htmlToMarkdown`:
   - Input: `'<strong>Hello</strong> <a href="https://x.com">world</a>'` → output contains `**Hello**` and `[world](https://x.com)`
   - Input: `'<bc-attachment filename="report.pdf" content-type="application/pdf"></bc-attachment>'` → output is `[Attachment: report.pdf (application/pdf)]`
   - Input: `'<mention>Alice Smith</mention>'` → output is `[@Alice Smith]`
   - Input: `'<bc-gallery></bc-gallery>'` → output is `[Gallery]`
   - Input: `''` → output is `''`
   - Input: any string → output must NOT match `/<[^>]+>/` (no HTML remaining)
3. For `paginate`: write a mock where `getRaw` returns a response with `link: '<https://3.basecampapi.com/123/x.json?page=2>; rel="next"'` and a body of 150 items → verify `has_more: true`, `next_page: 2`, `items.length: 100`.
  </verify>
  <done>
- `htmlToMarkdown` passes all conversion cases including Basecamp-specific tags
- No HTML angle brackets remain in any `htmlToMarkdown` output
- `paginate` returns `PaginatedResult` shape; Link header parsing correctly extracts `next_page`
- 100-item cap enforced; 50KB cap logic in place
- TypeScript compilation clean
  </done>
</task>

<task type="auto">
  <name>Task 2: Zod schemas for all 6 content types and BasecampClient endpoint methods</name>
  <files>
    src/client/schemas/project.ts
    src/client/schemas/message.ts
    src/client/schemas/todo.ts
    src/client/schemas/document.ts
    src/client/schemas/campfire.ts
    src/client/schemas/attachment.ts
    src/client/schemas/index.ts
    src/client/BasecampClient.ts
  </files>
  <action>
**Zod schemas — normalized BaseEnvelope shape for all 6 content types.**

All schemas use the shared `BaseEnvelopeSchema` base:
```typescript
// In each schema file, define the full schema (not importing a base — keep schemas self-contained)
const AuthorSchema = z.object({
  name: z.string(),
  email_address: z.string().optional().default(''),
});
```

**`src/client/schemas/project.ts`**
```typescript
export const ProjectSchema = z.object({
  id: z.number(),
  title: z.string(),   // mapped from raw "name" field
  author: AuthorSchema,
  created_at: z.string(),
  updated_at: z.string(),
  url: z.string(),     // mapped from raw "app_url" field
  status: z.string(),  // "active" | "archived" | "trashed"
  description: z.string().default(''),
});
export type Project = z.infer<typeof ProjectSchema>;
```
Note: Basecamp `name` field → normalized `title`. `app_url` → `url`. Use `.transform()` on raw input.

**`src/client/schemas/message.ts`**
```typescript
export const MessageSchema = z.object({
  id: z.number(),
  title: z.string(),   // raw "subject" field
  author: AuthorSchema,
  created_at: z.string(),
  updated_at: z.string(),
  url: z.string(),     // raw "app_url"
  content: z.string(), // html-to-markdown converted from raw "content" HTML
});
export type Message = z.infer<typeof MessageSchema>;
```

**`src/client/schemas/todo.ts`**
```typescript
export const TodoSchema = z.object({
  id: z.number(),
  title: z.string(),   // raw "content" field (todo title)
  author: AuthorSchema,
  created_at: z.string(),
  updated_at: z.string(),
  url: z.string(),     // raw "app_url"
  content: z.string(), // description HTML → markdown (may be empty)
  completed: z.boolean(),
  due_on: z.string().nullable(),
});
export type Todo = z.infer<typeof TodoSchema>;

export const TodoListSchema = z.object({
  id: z.number(),
  title: z.string(),   // raw "name"
  author: AuthorSchema,
  created_at: z.string(),
  updated_at: z.string(),
  url: z.string(),
  content: z.string().default(''), // description → markdown
  todos_count: z.number().optional(),
});
export type TodoList = z.infer<typeof TodoListSchema>;
```

**`src/client/schemas/document.ts`**
```typescript
export const DocumentSchema = z.object({
  id: z.number(),
  title: z.string(),
  author: AuthorSchema,
  created_at: z.string(),
  updated_at: z.string(),
  url: z.string(),
  content: z.string(), // full html → markdown (for get_document)
});
export type Document = z.infer<typeof DocumentSchema>;

// Used for list_documents — content truncated to 500 chars (NFR-4.3)
export const DocumentSummarySchema = DocumentSchema.extend({
  content: z.string().transform(c => c.slice(0, 500)),
  truncated: z.boolean().optional().default(true),
});
export type DocumentSummary = z.infer<typeof DocumentSummarySchema>;
```

**`src/client/schemas/campfire.ts`**
```typescript
export const CampfireLineSchema = z.object({
  id: z.number(),
  title: z.string().default(''),  // campfire lines have no title — use empty string for envelope conformance
  author: AuthorSchema,
  created_at: z.string(),
  updated_at: z.string(),
  url: z.string(),
  content: z.string(), // html → markdown
});
export type CampfireLine = z.infer<typeof CampfireLineSchema>;
```

**`src/client/schemas/attachment.ts`** (NFR-4.4 — metadata only, no binary):
```typescript
export const AttachmentSchema = z.object({
  id: z.number(),
  title: z.string(),       // raw "filename"
  author: AuthorSchema,
  created_at: z.string(),
  updated_at: z.string(),
  url: z.string(),         // raw "app_url" — deeplink, NOT download URL
  content: z.string().default(''), // empty — no binary content ever
  content_type: z.string(),
  byte_size: z.number(),
  download_url: z.string().optional(), // include URL string only — never fetch binary (NFR-4.4)
});
export type Attachment = z.infer<typeof AttachmentSchema>;
```

**`src/client/schemas/index.ts`**
Re-export everything from all 6 schema files.

---

**BasecampClient endpoint methods (extend `src/client/BasecampClient.ts`):**

Import `paginate`, `htmlToMarkdown`, and all schemas. Add these 7 public methods:

```typescript
// Projects — no bucket context needed
async listProjects(page = 1): Promise<PaginatedResult<Project>>

// Messages — requires bucket_id and message_board_id (two-step lookup handled by caller in Phase 3)
async listMessages(bucketId: number, boardId: number, page = 1): Promise<PaginatedResult<Message>>

// Todo lists
async listTodoLists(bucketId: number, todoSetId: number, page = 1): Promise<PaginatedResult<TodoList>>

// Todos within a list
async listTodos(bucketId: number, todoListId: number, page = 1): Promise<PaginatedResult<Todo>>

// Documents — summary (truncated) for list, full for get
async listDocuments(bucketId: number, vaultId: number, page = 1): Promise<PaginatedResult<DocumentSummary>>
async getDocument(bucketId: number, documentId: number): Promise<Document>

// Campfire lines
async listCampfireLines(bucketId: number, chatId: number, page = 1): Promise<PaginatedResult<CampfireLine>>

// Attachments — metadata only
async listAttachments(bucketId: number, vaultId: number, page = 1): Promise<PaginatedResult<Attachment>>
```

Each list method follows this pattern (example: `listProjects`):
```typescript
async listProjects(page = 1): Promise<PaginatedResult<Project>> {
  return paginate(this, 'projects.json', page, (raw) => {
    const r = raw as Record<string, unknown>;
    return ProjectSchema.parse({
      id: r['id'],
      title: r['name'],          // normalize name → title
      author: r['creator'],      // Basecamp uses "creator" not "author"
      created_at: r['created_at'],
      updated_at: r['updated_at'],
      url: r['app_url'],         // normalize app_url → url
      status: r['status'],
      description: r['description'] ?? '',
    });
  });
}
```

For content fields with HTML: call `htmlToMarkdown(r['content'] as string)` before passing to schema parse.

For `getDocument` (single item, not paginated):
```typescript
async getDocument(bucketId: number, documentId: number): Promise<Document> {
  const raw = await this.get<Record<string, unknown>>(
    `buckets/${bucketId}/documents/${documentId}.json`
  );
  return DocumentSchema.parse({
    ...normalizeEnvelopeFields(raw),
    content: htmlToMarkdown(raw['content'] as string),
  });
}
```

Add a private `normalizeEnvelopeFields()` helper to reduce repetition across methods:
```typescript
private normalizeEnvelopeFields(raw: Record<string, unknown>) {
  return {
    id: raw['id'],
    title: raw['title'] ?? raw['name'] ?? raw['subject'] ?? raw['filename'] ?? '',
    author: raw['creator'] ?? raw['author'],
    created_at: raw['created_at'],
    updated_at: raw['updated_at'],
    url: raw['app_url'],
  };
}
```

Field name mappings from raw Basecamp JSON to normalized schema:
| Content type | raw `title` field | raw `content` field | raw `url` field | raw `author` field |
|---|---|---|---|---|
| Project | `name` | `description` (plain) | `app_url` | `creator` |
| Message | `subject` | `content` (HTML) | `app_url` | `creator` |
| TodoList | `name` | `description` (HTML) | `app_url` | `creator` |
| Todo | `content` (is the title) | `description` (HTML) | `app_url` | `creator` |
| Document | `title` | `content` (HTML) | `app_url` | `creator` |
| CampfireLine | (no title) | `content` (HTML) | `app_url` | `creator` |
| Attachment | `filename` | (empty) | `app_url` | `creator` |

Install `zod` if not in package.json: `npm install zod`. Install `node-html-parser` if not present: `npm install node-html-parser`.
  </action>
  <verify>
1. Run `npx tsc --noEmit` — zero type errors across all schema files and updated BasecampClient.
2. Write a smoke test that:
   - Creates a mock `PaginatedResult` by directly calling `ProjectSchema.parse()` with a sample raw Basecamp project object
   - Confirms `title` is mapped from `name`, `url` from `app_url`
   - Confirms a message with HTML content `'<strong>Hello</strong>'` parses to `content: '**Hello**'`
   - Confirms `DocumentSummarySchema.parse({ ..., content: 'x'.repeat(600) }).content.length === 500`
   - Confirms `AttachmentSchema.parse({ ..., content: '' }).content === ''` (no binary leak)
3. Run `grep -r "<" src/client/` after a sample transform — confirm no untransformed HTML in schema outputs.
  </verify>
  <done>
- All 6 schema files exist with correct exports
- `schemas/index.ts` re-exports all types
- `BasecampClient` has all 7 endpoint methods (6 list + 1 get)
- Field name normalization (name→title, app_url→url, creator→author) applied in every method
- HTML content fields run through `htmlToMarkdown()` before schema validation
- `DocumentSummarySchema` truncates content to 500 chars
- `AttachmentSchema` has `content: ''` — no binary data path exists
- TypeScript compilation clean
  </done>
</task>

</tasks>

<verification>
Run `npx tsc --noEmit` — must report zero errors.

Confirm all files exist:
- `src/client/paginate.ts` — exports `paginate`, `PaginatedResult`
- `src/client/html-to-markdown.ts` — exports `htmlToMarkdown`
- `src/client/schemas/{project,message,todo,document,campfire,attachment}.ts` — each with schema + type export
- `src/client/schemas/index.ts` — re-exports all

Spot-check the full pipeline with a manually constructed mock:
1. Create a fake raw Message object: `{ id: 1, subject: 'Test', content: '<p>Hello <strong>world</strong></p>', creator: { name: 'Alice', email_address: 'a@x.com' }, created_at: '2026-01-01T00:00:00Z', updated_at: '2026-01-01T00:00:00Z', app_url: 'https://basecamp.com/...' }`
2. Pass through `MessageSchema.parse()` with HTML conversion applied
3. Assert: `result.content` equals `'Hello **world**\n\n'` (or similar — no HTML tags)
4. Assert: `result.title` equals `'Test'` (from `subject`)
5. Assert: `result.url` equals the `app_url` value

Confirm `paginate()` with a 150-item array returns exactly 100 items with `has_more: true`.

Confirm `htmlToMarkdown('<bc-attachment filename="file.pdf" content-type="application/pdf"></bc-attachment>')` returns `'[Attachment: file.pdf (application/pdf)]'`.
</verification>

<success_criteria>
1. `BasecampClient` now has 7 endpoint methods returning typed `PaginatedResult<T>` or single `T` — no raw Basecamp JSON escapes
2. Every list method returns `{ items, has_more, next_page }` — the pagination envelope (NFR-2.2)
3. Link header with `rel="next"` correctly populates `has_more: true` and `next_page: N` (NFR-2.1)
4. `page` parameter is forwarded as `searchParams.page` on every list call (NFR-2.3)
5. All rich-text fields are markdown — no HTML characters in schema output (NFR-3.1, NFR-3.3)
6. `<bc-attachment>`, `<mention>`, `<bc-gallery>` are converted to readable references (NFR-3.2)
7. List responses are hard-capped at 100 items (NFR-4.1)
8. Total response payload is capped at 50KB with graceful item trimming (NFR-4.2)
9. Document list uses `DocumentSummarySchema` truncating content to 500 chars (NFR-4.3)
10. Attachment schema has `content: ''` — binary content has no path through the client (NFR-4.4)
</success_criteria>

<output>
After completion, create `.planning/phases/02-api-client-infrastructure/02-02-SUMMARY.md` following the summary template at `@/home/het/.claude/get-shit-done/templates/summary.md`.

Key items to record:
- All 7 endpoint method signatures (Phase 3 MCP tools will call these directly)
- Field name mapping table (raw Basecamp → normalized schema field names)
- `PaginatedResult<T>` interface definition (Phase 3 tools return this shape to agents)
- `htmlToMarkdown` conversion rules applied (for Phase 5 test suite)
- Any Basecamp API field name surprises discovered during implementation
</output>
