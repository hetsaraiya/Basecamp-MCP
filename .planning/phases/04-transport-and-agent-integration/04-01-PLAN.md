---
phase: 04-transport-and-agent-integration
plan: "01"
type: execute
wave: 1
depends_on:
  - "03-02"
files_modified:
  - src/auth/store.ts
  - src/server.ts
  - src/index.ts
  - package.json
autonomous: true
requirements:
  - FR-8.5
  - NFR-6.1
  - NFR-6.2

must_haves:
  truths:
    - "A user who has completed OAuth receives a personal MCP URL (e.g. https://host/mcp/<uuid>) that they can paste into Claude Desktop or Cursor config"
    - "POST /mcp/:userToken with a valid userToken creates a new MCP session, initializes tools for that user, and returns a Mcp-Session-Id header"
    - "Subsequent POST/GET to /mcp/:userToken with a Mcp-Session-Id routes to the correct session — never another user's session"
    - "DELETE /mcp/:userToken with a Mcp-Session-Id terminates that session and cleans up the sessions Map entry"
    - "An unknown userToken (not in SQLite) returns HTTP 401"
    - "With TRANSPORT=stdio set, src/index.ts starts in stdio mode using BASECAMP_USER_ID from env — no HTTP server started"
    - "With TRANSPORT unset or omitted, src/index.ts starts the HTTP Express server normally"
  artifacts:
    - path: "src/auth/store.ts"
      provides: "mcp_token column in tokens table + getByMcpToken(mcpToken) method + saveMcpToken(userId, mcpToken)"
      contains: "getByMcpToken"
    - path: "src/server.ts"
      provides: "/mcp/:userToken POST/GET/DELETE handler with sessions Map and StreamableHTTPServerTransport wiring"
      contains: "StreamableHTTPServerTransport"
    - path: "src/index.ts"
      provides: "Main entry point — conditionally starts stdio or HTTP depending on TRANSPORT env var"
      contains: "TRANSPORT"
  key_links:
    - from: "src/server.ts /mcp/:userToken POST handler"
      to: "src/auth/store.ts getByMcpToken()"
      via: "req.params.userToken lookup returns basecampUserId, 401 if null"
      pattern: "getByMcpToken"
    - from: "src/server.ts initialize request handler"
      to: "src/tools/tools.ts createTools()"
      via: "new McpServer per session via createTools(userId, tokenStore)"
      pattern: "createTools\\("
    - from: "src/server.ts"
      to: "StreamableHTTPServerTransport"
      via: "transport.handleRequest(req, res, req.body) for POST/GET/DELETE"
      pattern: "handleRequest"
    - from: "src/server.ts transport.onsessioninitialized"
      to: "sessions Map"
      via: "sessions.set(sessionId, { transport, server, userId }) on initialize"
      pattern: "onsessioninitialized"
    - from: "src/index.ts"
      to: "src/mcp.ts OR src/server.ts"
      via: "TRANSPORT === 'stdio' branches to StdioServerTransport path; else startServer()"
      pattern: "TRANSPORT.*stdio"
---

<objective>
Wire Streamable HTTP transport into the Express server with per-user URL routing, add mcp_token to SQLite for URL-key lookup, update the OAuth callback to return the user's personal MCP URL, implement session Map lifecycle management, and create the main entry point that conditionally starts stdio or HTTP mode.

Note: `@modelcontextprotocol/sdk` and `src/tools/tools.ts` (with `createTools()`) are provided by Phase 3 (plans 03-01 and 03-02). This plan depends on 03-02 completing first — do not attempt to install the SDK or create tools.ts here.

Purpose: This plan makes the server connectable by real agents. Without it, the 11 MCP tools exist only in stdio testing mode. After this plan, any authenticated user has a personal URL they paste into Claude Desktop or Cursor, and their agent calls return exclusively their Basecamp data — other users' data is structurally unreachable.

Output: Updated src/auth/store.ts (mcp_token column + lookup), updated src/server.ts (/mcp/:userToken route with full session lifecycle), new src/index.ts (TRANSPORT-conditional entry point), updated package.json scripts (start and mcp commands updated).
</objective>

<execution_context>
@/home/het/.claude/get-shit-done/workflows/execute-plan.md
@/home/het/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/auth/store.ts
@src/auth/oauth.ts
@src/server.ts
@src/tools/tools.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mcp_token column to SQLite and update TokenStore with getByMcpToken()</name>
  <files>src/auth/store.ts</files>
  <action>
The `/mcp/:userToken` route needs to resolve a URL-safe UUID back to a `basecampUserId`. This requires a new `mcp_token` column in the tokens table and a lookup method. The `mcp_token` is issued post-OAuth and stays stable for the user's lifetime (not rotated like access tokens).

**Step 1 — Add `mcp_token` column to the migration:**

In `src/auth/store.ts`, update `migrate()` to add a second migration that adds the `mcp_token` column. Use `ALTER TABLE ... ADD COLUMN` with `IF NOT EXISTS` guarded by checking `PRAGMA table_info(tokens)`. The safest pattern with better-sqlite3 is to attempt the ALTER and catch if the column already exists (SQLite returns error code `SQLITE_ERROR` for duplicate column add):

```typescript
private migrate() {
  this.db.exec(`
    CREATE TABLE IF NOT EXISTS tokens (
      basecamp_user_id INTEGER PRIMARY KEY,
      access_token     TEXT NOT NULL,
      refresh_token    TEXT NOT NULL,
      expires_at       INTEGER NOT NULL,
      account_id       TEXT NOT NULL,
      email            TEXT NOT NULL,
      created_at       INTEGER NOT NULL DEFAULT (unixepoch('now') * 1000),
      updated_at       INTEGER NOT NULL DEFAULT (unixepoch('now') * 1000)
    );
  `);

  // Migration: add mcp_token column (idempotent — ALTER TABLE fails silently if column exists)
  try {
    this.db.exec(`ALTER TABLE tokens ADD COLUMN mcp_token TEXT;`);
  } catch {
    // Column already exists — safe to ignore
  }
}
```

**Step 2 — Add `saveMcpToken(userId, mcpToken)` method:**

Add this method to the `TokenStore` class after `revoke()`:

```typescript
/**
 * saveMcpToken — stores the user's personal MCP URL key.
 *
 * Called once after OAuth completes. The mcp_token is a UUID issued by the
 * server and used as the path param in /mcp/:userToken to route MCP sessions
 * to the correct basecampUserId without requiring Authorization headers.
 *
 * Architecture decision (STATE.md 2026-02-19): unique URL per user, no Bearer token.
 */
saveMcpToken(basecampUserId: number, mcpToken: string): void {
  this.db.prepare(
    'UPDATE tokens SET mcp_token = ? WHERE basecamp_user_id = ?'
  ).run(mcpToken, basecampUserId);
}
```

**Step 3 — Add `getByMcpToken(mcpToken)` method:**

Add this method to the `TokenStore` class after `saveMcpToken()`:

```typescript
/**
 * getByMcpToken — resolves an mcp_token URL key to a TokenRecord.
 *
 * Called by the /mcp/:userToken Express route to authenticate the request.
 * Returns null if the token is unknown or has been revoked (mcp_token IS NULL).
 */
getByMcpToken(mcpToken: string): TokenRecord | null {
  const row = this.db.prepare(
    'SELECT * FROM tokens WHERE mcp_token = ?'
  ).get(mcpToken) as Record<string, unknown> | undefined;

  if (!row) return null;
  return this.rowToRecord(row);
}
```

**Step 4 — Compile check:**

Run `npx tsc --noEmit` and fix any type errors before proceeding to Task 2.
  </action>
  <verify>
1. `npx tsc --noEmit` exits 0
2. `grep -n "saveMcpToken\|getByMcpToken\|mcp_token" src/auth/store.ts | head -20` shows all three additions
3. `grep "ALTER TABLE tokens ADD COLUMN mcp_token" src/auth/store.ts` returns a match
  </verify>
  <done>
src/auth/store.ts has: mcp_token column migration via ALTER TABLE (try/catch), saveMcpToken(userId, mcpToken) UPDATE method, getByMcpToken(mcpToken) SELECT method. tsc compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update OAuth callback to generate mcp_token and return mcp_url</name>
  <files>src/server.ts</files>
  <action>
Update the `/oauth/callback` handler in `src/server.ts` to generate a stable UUID for the user's personal MCP URL key, persist it via `tokenStore.saveMcpToken()`, and return the full `mcp_url` in the JSON response so the user can paste it into Claude Desktop or Cursor.

Replace the entire `app.get('/oauth/callback', ...)` block with:

```typescript
app.get('/oauth/callback', async (req, res) => {
  const code = req.query.code as string | undefined;
  if (!code) {
    res.status(400).send('Missing authorization code');
    return;
  }
  try {
    const tokenRecord = await handleCallback(code);
    tokenStore.save(tokenRecord);

    // Issue a stable UUID that becomes the user's personal MCP URL key.
    // Architecture decision (STATE.md 2026-02-19): unique URL per user, no Authorization header.
    const mcpToken = crypto.randomUUID();
    tokenStore.saveMcpToken(tokenRecord.basecampUserId, mcpToken);

    // Derive base URL for the MCP endpoint — strip the /oauth/callback path
    const redirectUri = process.env.BASECAMP_REDIRECT_URI ?? 'http://localhost:3000/oauth/callback';
    const baseUrl = redirectUri.replace(/\/oauth\/callback$/, '');
    const mcpUrl = `${baseUrl}/mcp/${mcpToken}`;

    res.json({
      message: 'OAuth complete — paste your MCP URL into Claude Desktop or Cursor',
      mcp_url: mcpUrl,
      user: {
        basecampUserId: tokenRecord.basecampUserId,
        email: tokenRecord.email,
        accountId: tokenRecord.accountId,
      },
    });
  } catch (err) {
    const message = err instanceof Error ? err.message : 'OAuth callback failed';
    res.status(500).json({ error: message });
  }
});
```

If `crypto.randomUUID` raises a type error, add `import { randomUUID } from 'node:crypto'` at the top and call `randomUUID()` instead of `crypto.randomUUID()`.

Run `npx tsc --noEmit` and confirm it exits 0 before proceeding to Task 3.
  </action>
  <verify>
1. `npx tsc --noEmit` exits 0
2. `grep "mcp_url" src/server.ts` shows the mcp_url field in the /oauth/callback response
3. `grep "saveMcpToken" src/server.ts` shows the call to persist the UUID
4. `grep "crypto.randomUUID\|randomUUID" src/server.ts` shows UUID generation in the callback handler
  </verify>
  <done>
src/server.ts /oauth/callback generates a UUID via randomUUID(), calls tokenStore.saveMcpToken(userId, mcpToken), and returns { mcp_url: "http://host/mcp/<uuid>", user: {...} } in the JSON response. tsc compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add /mcp/:userToken route with session Map lifecycle (StreamableHTTPServerTransport)</name>
  <files>src/server.ts</files>
  <action>
Add the Streamable HTTP transport wiring to `src/server.ts`. This is the core of Phase 4 — it creates per-user MCP sessions, enforces authentication via mcp_token lookup, and manages the session Map lifecycle.

**Step 1 — Add imports at the top of src/server.ts** (after the existing imports):

```typescript
import { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js';
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { createTools } from './tools/tools.js';
```

Note: `@modelcontextprotocol/sdk` is installed by Phase 3 plan 03-01. `createTools` is exported from `src/tools/tools.ts` created by Phase 3 plan 03-02.

**Step 2 — Add the session Map and /mcp/:userToken route** (place after the `/oauth/revoke` handler, before the `/health` route):

```typescript
// ---------------------------------------------------------------------------
// Session management for Streamable HTTP transport
// ---------------------------------------------------------------------------

interface Session {
  transport: StreamableHTTPServerTransport;
  server: McpServer;
  userId: number;
}

// Map from Mcp-Session-Id header value → active session
// Each session is bound to exactly one basecampUserId (via mcp_token lookup at initialization).
// Architecture decision (STATE.md 2026-02-19): session-map pattern, unique URL per user.
const sessions = new Map<string, Session>();

// ---------------------------------------------------------------------------
// POST /mcp/:userToken — initialize or continue an MCP session
// GET  /mcp/:userToken — SSE stream for server-sent events
// DELETE /mcp/:userToken — terminate session
// ---------------------------------------------------------------------------

app.use(express.json({ type: 'application/json' }));

app.all('/mcp/:userToken', async (req, res) => {
  const { userToken } = req.params;

  // Resolve the userToken to a TokenRecord — returns 401 if unknown
  const tokenRecord = tokenStore.getByMcpToken(userToken);
  if (!tokenRecord) {
    res.status(401).json({ error: 'Invalid or expired MCP token. Re-authenticate at /oauth/start' });
    return;
  }

  const sessionId = req.headers['mcp-session-id'] as string | undefined;

  // --- DELETE: terminate an existing session ---
  if (req.method === 'DELETE') {
    if (sessionId) {
      const session = sessions.get(sessionId);
      if (session) {
        await session.transport.close();
        sessions.delete(sessionId);
      }
    }
    res.status(204).end();
    return;
  }

  // --- Existing session: route to established transport ---
  if (sessionId && sessions.has(sessionId)) {
    const session = sessions.get(sessionId)!;
    await session.transport.handleRequest(req, res, req.body);
    return;
  }

  // --- New session: initialize transport + tools for this user ---
  // This branch handles the MCP initialize request (first POST, no Mcp-Session-Id yet).
  // StreamableHTTPServerTransport generates the session ID via sessionIdGenerator.
  const transport = new StreamableHTTPServerTransport({
    sessionIdGenerator: () => crypto.randomUUID(),
    onsessioninitialized: (newSessionId) => {
      // Bind the new session to this user's server instance.
      // onsessioninitialized fires synchronously before the response is sent,
      // so the session is in the Map before any tool calls can arrive.
      sessions.set(newSessionId, { transport, server, userId: tokenRecord.basecampUserId });
    },
  });

  // Create a fresh McpServer with tools bound to this user's basecampUserId.
  // createTools() is the Phase 3 factory — returns McpServer with all 11 tools.
  const server = createTools(tokenRecord.basecampUserId, tokenStore);

  // Connect the MCP server to the transport — must happen before handleRequest
  await server.connect(transport);

  // Register cleanup when transport closes (client disconnect, network drop, etc.)
  transport.onclose = () => {
    if (transport.sessionId) {
      sessions.delete(transport.sessionId);
    }
  };

  await transport.handleRequest(req, res, req.body);
});
```

**Step 3 — Compile check:**

Run `npx tsc --noEmit`. If `StreamableHTTPServerTransport` is not found at the import path, check the installed SDK version with `cat node_modules/@modelcontextprotocol/sdk/package.json | grep '"version"'` and try the lowercase variant `@modelcontextprotocol/sdk/server/streamableHttp.js` if needed.

If `crypto.randomUUID` raises a type error in the sessionIdGenerator, use the already-imported `randomUUID` from `node:crypto` (if added in Task 2) or add `import { randomUUID } from 'node:crypto'`.
  </action>
  <verify>
1. `npx tsc --noEmit` exits 0
2. `grep -n "StreamableHTTPServerTransport\|sessions\|onsessioninitialized\|getByMcpToken" src/server.ts | head -20` shows all four
3. `grep "sessions.set\|sessions.delete\|sessions.has" src/server.ts | head -10` shows Map lifecycle operations
4. `grep "/mcp/:userToken" src/server.ts` shows the route registration via app.all()
5. `grep "createTools" src/server.ts` shows the createTools(userId, tokenStore) call in new-session branch
  </verify>
  <done>
src/server.ts: sessions Map declared with Session interface. app.all('/mcp/:userToken') handles POST/GET/DELETE. Unknown userToken returns 401. New session creates StreamableHTTPServerTransport + calls createTools(userId, tokenStore). onsessioninitialized stores in sessions Map. transport.onclose cleans up. DELETE closes transport and removes from Map. tsc compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create src/index.ts entry point with TRANSPORT=stdio conditional</name>
  <files>src/index.ts, package.json</files>
  <action>
Create a new `src/index.ts` that is the main entry point. It reads `TRANSPORT` from env and either starts in stdio mode (for local dev without OAuth) or starts the HTTP Express server (for multi-user production use).

**Step 1 — Create src/index.ts:**

```typescript
/**
 * src/index.ts — Main entry point for the Basecamp MCP server.
 *
 * Two modes controlled by TRANSPORT env var:
 *
 *   TRANSPORT=stdio (default for local single-user dev):
 *     Reads BASECAMP_USER_ID from env, creates tools for that user,
 *     connects StdioServerTransport. No OAuth flow needed.
 *     Same StdioServerTransport path as Phase 3 src/mcp.ts.
 *
 *   TRANSPORT unset or any other value (production):
 *     Starts Express HTTP server on PORT (default 3000).
 *     Serves /oauth/start, /oauth/callback, /oauth/revoke, /mcp/:userToken.
 *
 * NFR-6.2: TRANSPORT=stdio enables single-user stdio mode for local development.
 */

import { tokenStore } from './auth/store.js';
import { createTools } from './tools/tools.js';

if (process.env.TRANSPORT === 'stdio') {
  // --- Stdio mode ---
  // Requires BASECAMP_USER_ID env var pointing to an already-stored token.
  // Use `npm run mcp` (which sets this) or supply manually.
  const userIdStr = process.env.BASECAMP_USER_ID;
  if (!userIdStr) {
    console.error('TRANSPORT=stdio requires BASECAMP_USER_ID env var. Set it to your Basecamp user ID.');
    process.exit(1);
  }
  const userId = Number(userIdStr);
  if (isNaN(userId)) {
    console.error('BASECAMP_USER_ID must be a numeric Basecamp user ID.');
    process.exit(1);
  }

  // Dynamic import to avoid loading StdioServerTransport in HTTP mode
  const { StdioServerTransport } = await import('@modelcontextprotocol/sdk/server/stdio.js');

  const server = createTools(userId, tokenStore);
  const transport = new StdioServerTransport();
  await server.connect(transport);

  // Keep the process alive (StdioServerTransport reads from stdin until closed)
  console.error(`Basecamp MCP server running in stdio mode for user ${userId}`);
} else {
  // --- HTTP mode ---
  const { startServer } = await import('./server.js');
  startServer();
}
```

**Step 2 — Update package.json scripts:**

Update `package.json` scripts section. The current `dev` script uses `src/server.ts` directly. In Phase 4:
- `dev` should run `src/index.ts` (the new entry point) so `TRANSPORT=stdio` can be tested without OAuth
- `start` should run `dist/index.js` (compiled output from `src/index.ts`)
- Add `mcp` script for stdio dev mode (same purpose as Phase 3 `mcp` script but uses new entry point)

Replace the scripts section in `package.json`:

```json
"scripts": {
  "dev": "tsx watch src/index.ts",
  "build": "tsc",
  "start": "node dist/index.js",
  "mcp": "TRANSPORT=stdio tsx src/index.ts"
}
```

Note: The `mcp` script uses `TRANSPORT=stdio` without `watch` (stdio mode doesn't benefit from watch).

**Step 3 — Verify `src/server.ts` still exports `startServer`:**

Check that `src/server.ts` exports `startServer` — it already does from Phase 1. No changes needed to server.ts for this step.

**Step 4 — Compile check:**

Run `npx tsc --noEmit`. If top-level await in `src/index.ts` raises errors, confirm `tsconfig.json` has `"module": "NodeNext"` and `"target": "ES2022"` or higher — top-level await requires both. The Phase 1 tsconfig already uses NodeNext.

Fix any import resolution errors by ensuring the `.js` extension is used on all local imports inside `src/index.ts`.
  </action>
  <verify>
1. `npx tsc --noEmit` exits 0
2. `ls src/index.ts` confirms file exists
3. `grep -n "TRANSPORT.*stdio\|StdioServerTransport\|startServer" src/index.ts` shows all three branches
4. `grep "BASECAMP_USER_ID" src/index.ts` shows the env var check with process.exit(1) guard
5. `grep '"dev"\|"start"\|"mcp"' package.json` shows updated scripts pointing to src/index.ts and dist/index.js
6. `grep "src/index.ts\|dist/index.js" package.json` confirms entry point update
  </verify>
  <done>
src/index.ts created with TRANSPORT=stdio branch (StdioServerTransport + BASECAMP_USER_ID validation) and HTTP branch (startServer() from server.ts). package.json scripts updated: dev runs src/index.ts, start runs dist/index.js, mcp script uses TRANSPORT=stdio. tsc compiles clean.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors after all four tasks
- `grep "getByMcpToken\|saveMcpToken\|mcp_token" src/auth/store.ts` returns matches for all three
- `grep "StreamableHTTPServerTransport\|onsessioninitialized\|sessions.set\|sessions.delete" src/server.ts` returns matches for all four
- `grep "mcp_url" src/server.ts` shows the URL returned in OAuth callback response
- `grep "TRANSPORT.*stdio" src/index.ts` shows the conditional entry point
- `grep '"mcp"' package.json` shows the mcp script with TRANSPORT=stdio
- `grep "src/index.ts" package.json` shows dev and start scripts point to new entry point
</verification>

<success_criteria>
1. TokenStore.getByMcpToken(mcpToken) resolves a URL UUID to a TokenRecord (or null for unknown)
2. TokenStore.saveMcpToken(userId, mcpToken) persists the UUID to the mcp_token column
3. Migration adds mcp_token column idempotently (ALTER TABLE with try/catch)
4. /oauth/callback generates a UUID, stores it, and returns { mcp_url: "http://host/mcp/<uuid>" } (FR-8.5)
5. POST /mcp/:userToken with unknown userToken returns 401 (no session created)
6. POST /mcp/:userToken with known userToken + no Mcp-Session-Id creates new StreamableHTTPServerTransport, calls createTools(userId, tokenStore), registers session in sessions Map
7. Subsequent POST/GET with Mcp-Session-Id routes to existing session — not creating a new one
8. DELETE /mcp/:userToken closes transport and removes session from Map
9. transport.onclose cleans up sessions Map on unexpected disconnect (NFR-6.1 session isolation)
10. src/index.ts: TRANSPORT=stdio reads BASECAMP_USER_ID, creates tools, connects StdioServerTransport (NFR-6.2)
11. src/index.ts: TRANSPORT unset → startServer() HTTP mode
12. tsc compiles clean — all imports use .js extensions per NodeNext moduleResolution
</success_criteria>

<output>
After completion, create `.planning/phases/04-transport-and-agent-integration/04-01-SUMMARY.md`
</output>
