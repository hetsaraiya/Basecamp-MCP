---
phase: 01-oauth-foundation
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - .env.example
  - src/server.ts
  - src/auth/oauth.ts
autonomous: true
requirements:
  - FR-1.1
  - FR-1.2
  - FR-1.3

user_setup:
  - service: basecamp-launchpad
    why: "OAuth 2.0 app credentials — required to initiate the auth flow"
    env_vars:
      - name: BASECAMP_CLIENT_ID
        source: "https://launchpad.37signals.com → Register your application → copy Client ID"
      - name: BASECAMP_CLIENT_SECRET
        source: "https://launchpad.37signals.com → Register your application → copy Client Secret"
      - name: BASECAMP_REDIRECT_URI
        source: "Set to http://localhost:3000/oauth/callback for local dev; must match what you register in Launchpad"
      - name: PORT
        source: "Optional — defaults to 3000"
    dashboard_config:
      - task: "Register a new application"
        location: "https://launchpad.37signals.com → Integrations → Register an app"
        notes: "Set Redirect URI to http://localhost:3000/oauth/callback. Product: Basecamp 3."

must_haves:
  truths:
    - "Running `npm run dev` starts an Express server on PORT (default 3000) without errors"
    - "Visiting GET /oauth/start redirects the browser to launchpad.37signals.com with correct type=web_server, client_id, and redirect_uri query params"
    - "After completing the Basecamp Launchpad consent screen, the browser is redirected to /oauth/callback with a code param"
    - "The callback handler exchanges the code for tokens via POST to launchpad.37signals.com/authorization/token and then fetches GET launchpad.37signals.com/authorization.json to resolve account_id"
    - "handleCallback returns a TokenRecord containing accessToken, refreshToken, expiresAt, accountId, basecampUserId, and email"
  artifacts:
    - path: "package.json"
      provides: "Project dependencies and npm scripts"
      contains: "simple-oauth2, express, better-sqlite3, typescript"
    - path: "tsconfig.json"
      provides: "TypeScript compiler config targeting Node.js 22, ESM modules"
      contains: "module: NodeNext"
    - path: "src/server.ts"
      provides: "Express app entry point with /oauth/start and /oauth/callback routes mounted"
      exports: ["app", "startServer"]
    - path: "src/auth/oauth.ts"
      provides: "startAuthFlow() and handleCallback() functions, TokenRecord type"
      exports: ["startAuthFlow", "handleCallback", "TokenRecord"]
  key_links:
    - from: "src/server.ts"
      to: "src/auth/oauth.ts"
      via: "import { startAuthFlow, handleCallback }"
      pattern: "startAuthFlow|handleCallback"
    - from: "src/auth/oauth.ts"
      to: "launchpad.37signals.com/authorization/token"
      via: "simple-oauth2 AuthorizationCode.getToken()"
      pattern: "getToken|simple-oauth2"
    - from: "src/auth/oauth.ts"
      to: "launchpad.37signals.com/authorization.json"
      via: "fetch GET after token exchange"
      pattern: "authorization\\.json"
---

<objective>
Bootstrap the project from scratch and implement the Basecamp OAuth 2.0 Authorization Code flow.

Purpose: Without a working OAuth flow, no team member can authenticate and no Basecamp API call can be made. This is the absolute foundation — everything else in the project depends on it.

Output: A running Express server with `/oauth/start` (initiates Basecamp auth) and `/oauth/callback` (exchanges code, resolves account_id, returns a TokenRecord). All project scaffolding (package.json, tsconfig, directory structure) is in place.
</objective>

<execution_context>
@/home/het/.claude/get-shit-done/workflows/execute-plan.md
@/home/het/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/STACK.md
@.planning/research/ARCHITECTURE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Project scaffolding — package.json, tsconfig, directory structure</name>
  <files>
    package.json
    tsconfig.json
    .env.example
    .gitignore
  </files>
  <action>
Create the Node.js + TypeScript project from scratch. This is a greenfield repo.

**package.json** — create with these exact fields:
```json
{
  "name": "basecamp-mcp",
  "version": "0.1.0",
  "type": "module",
  "engines": { "node": ">=22" },
  "scripts": {
    "dev": "tsx watch src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js"
  },
  "dependencies": {
    "express": "^4.21.0",
    "simple-oauth2": "^5.0.0",
    "better-sqlite3": "^9.0.0"
  },
  "devDependencies": {
    "@types/express": "^5.0.0",
    "@types/better-sqlite3": "^7.6.0",
    "@types/node": "^22.0.0",
    "tsx": "^4.0.0",
    "typescript": "^5.7.0"
  }
}
```

Note: `"type": "module"` enables ESM throughout. `tsx` is the dev runner (watch mode, no separate compile step needed for development).

**tsconfig.json** — target Node.js 22 ESM:
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

`module: NodeNext` + `moduleResolution: NodeNext` is required for ESM with Node.js 22. All imports within the project MUST use `.js` extensions (e.g., `import { foo } from './auth/oauth.js'`) — TypeScript resolves these to the `.ts` source files during compilation.

**.env.example** — document required environment variables:
```
PORT=3000
BASECAMP_CLIENT_ID=your_client_id_here
BASECAMP_CLIENT_SECRET=your_client_secret_here
BASECAMP_REDIRECT_URI=http://localhost:3000/oauth/callback
SQLITE_PATH=./tokens.db
```

**.gitignore** — include:
```
node_modules/
dist/
.env
tokens.db
*.db
```

After creating files, run `npm install` to install dependencies.

Create the `src/` directory structure:
```
src/
  server.ts
  auth/
    oauth.ts
    store.ts      (empty placeholder — implemented in Plan 01-02)
```
  </action>
  <verify>
Run: `npm install` — exits 0, node_modules populated.
Run: `npx tsc --noEmit` — exits 0 with no type errors (only server.ts and auth/oauth.ts matter for this check; store.ts can be an empty export for now).
Check: `ls src/auth/` shows `oauth.ts` and `store.ts`.
  </verify>
  <done>
`npm install` succeeds, `node_modules/` exists with simple-oauth2, express, better-sqlite3. `npx tsc --noEmit` passes. Directory structure matches the layout above.
  </done>
</task>

<task type="auto">
  <name>Task 2: OAuth flow — /oauth/start, /oauth/callback, account_id resolution</name>
  <files>
    src/auth/oauth.ts
    src/server.ts
  </files>
  <action>
Implement the Basecamp OAuth 2.0 Authorization Code flow using `simple-oauth2` ^5.x.

---

**src/auth/oauth.ts** — core OAuth logic

Exports:
- `TokenRecord` interface (matches the schema from research)
- `startAuthFlow(redirectUri: string): string` — returns the Basecamp authorization URL
- `handleCallback(code: string): Promise<TokenRecord>` — exchanges code, fetches identity, returns TokenRecord

```typescript
// TokenRecord — stored per user, keyed by basecampUserId in Plan 01-02
export interface TokenRecord {
  accessToken: string;
  refreshToken: string;
  expiresAt: Date;
  accountId: string;       // bc3 account_id from authorization.json
  basecampUserId: number;
  email: string;
}
```

**simple-oauth2 setup** — use `AuthorizationCode` class:

```typescript
import { AuthorizationCode } from 'simple-oauth2';

const client = new AuthorizationCode({
  client: {
    id: process.env.BASECAMP_CLIENT_ID!,
    secret: process.env.BASECAMP_CLIENT_SECRET!,
  },
  auth: {
    tokenHost: 'https://launchpad.37signals.com',
    tokenPath: '/authorization/token',
    authorizePath: '/authorization/new',
  },
});
```

**startAuthFlow(redirectUri):**
```typescript
export function startAuthFlow(redirectUri: string): string {
  return client.authorizeURL({
    redirect_uri: redirectUri,
    type: 'web_server',   // Basecamp requires this param
  });
}
```

**handleCallback(code):**
1. Exchange code for tokens:
   ```typescript
   const tokenParams = { code, redirect_uri: process.env.BASECAMP_REDIRECT_URI! };
   const accessToken = await client.getToken(tokenParams);
   ```
   `accessToken.token` contains `access_token`, `refresh_token`, `expires_in` (seconds).

2. Compute `expiresAt`: `new Date(Date.now() + (accessToken.token.expires_in as number) * 1000)`.
   If `expires_in` is absent, default to 7200 seconds (2 hours) — Basecamp's typical TTL.

3. Fetch identity to resolve `account_id`:
   ```typescript
   const identityRes = await fetch('https://launchpad.37signals.com/authorization.json', {
     headers: {
       'Authorization': `Bearer ${accessToken.token.access_token}`,
       'User-Agent': 'Basecamp MCP (internal@openxcell.com)',
     },
   });
   const identity = await identityRes.json() as BasecampIdentity;
   ```

   The identity response shape:
   ```typescript
   interface BasecampIdentity {
     expires_at: string;
     identity: {
       id: number;
       email_address: string;
       first_name: string;
       last_name: string;
     };
     accounts: Array<{
       product: string;   // "bc3" for Basecamp 3
       id: number;
       name: string;
       href: string;
     }>;
   }
   ```

4. Filter accounts for `product === 'bc3'`:
   - If exactly one bc3 account → use its `id` as `accountId`
   - If multiple → use the first one (OpenXcell is a single-org team for v1; multi-account support is out of scope per PROJECT.md)
   - If zero bc3 accounts → throw `new Error('No Basecamp 3 account found for this user')`

5. Return `TokenRecord`:
   ```typescript
   return {
     accessToken: accessToken.token.access_token as string,
     refreshToken: accessToken.token.refresh_token as string,
     expiresAt,
     accountId: String(bc3Account.id),
     basecampUserId: identity.identity.id,
     email: identity.identity.email_address,
   };
   ```

DO NOT store the token in this function — that is `TokenStore`'s responsibility (Plan 01-02). `handleCallback` only resolves and returns the record.

---

**src/server.ts** — Express app with OAuth routes

```typescript
import express from 'express';
import { startAuthFlow, handleCallback } from './auth/oauth.js';

export const app = express();

app.get('/oauth/start', (_req, res) => {
  const redirectUri = process.env.BASECAMP_REDIRECT_URI!;
  const authUrl = startAuthFlow(redirectUri);
  res.redirect(authUrl);
});

app.get('/oauth/callback', async (req, res) => {
  const code = req.query.code as string | undefined;
  if (!code) {
    res.status(400).send('Missing authorization code');
    return;
  }
  try {
    const tokenRecord = await handleCallback(code);
    // Plan 01-02 will wire in TokenStore.save() here.
    // For now, confirm the flow works by returning the user info (not the tokens — never expose tokens in responses).
    res.json({
      message: 'OAuth complete',
      user: {
        basecampUserId: tokenRecord.basecampUserId,
        email: tokenRecord.email,
        accountId: tokenRecord.accountId,
      },
    });
  } catch (err) {
    const message = err instanceof Error ? err.message : 'OAuth callback failed';
    res.status(500).json({ error: message });
  }
});

// Health check
app.get('/health', (_req, res) => res.json({ status: 'ok' }));

export function startServer() {
  const port = Number(process.env.PORT ?? 3000);
  app.listen(port, () => {
    console.log(`Basecamp MCP server listening on http://localhost:${port}`);
    console.log(`OAuth start: http://localhost:${port}/oauth/start`);
  });
}

// Only start the server when run directly (not when imported in tests)
if (process.argv[1] === new URL(import.meta.url).pathname) {
  startServer();
}
```

**Important:**
- Never log or return `accessToken` or `refreshToken` in responses
- `import.meta.url` guard prevents double-start when server.ts is imported by other modules
- All internal imports use `.js` extension (e.g., `'./auth/oauth.js'`) per NodeNext module resolution
  </action>
  <verify>
1. `npx tsc --noEmit` exits 0 — no TypeScript errors.
2. Copy `.env.example` to `.env`, fill in real BASECAMP_CLIENT_ID and BASECAMP_CLIENT_SECRET.
3. `npm run dev` starts without errors, logs "Basecamp MCP server listening on http://localhost:3000".
4. `curl http://localhost:3000/health` returns `{"status":"ok"}`.
5. `curl -v http://localhost:3000/oauth/start` returns HTTP 302 with Location header containing `launchpad.37signals.com/authorization/new?type=web_server&client_id=...&redirect_uri=...`.
6. Visit `/oauth/start` in a browser, complete the Basecamp consent screen → browser is redirected to `/oauth/callback?code=...` and the response JSON contains `{ message: "OAuth complete", user: { basecampUserId, email, accountId } }`.
  </verify>
  <done>
Server starts, `/oauth/start` redirects to Basecamp Launchpad with correct params, completing the Basecamp consent flow redirects to `/oauth/callback` which returns a JSON object with `basecampUserId`, `email`, and `accountId` — proving that token exchange and `authorization.json` identity resolution both work end-to-end.
  </done>
</task>

</tasks>

<verification>
Overall checks after both tasks:

1. `npm install` — clean install, no peer dep warnings that matter
2. `npx tsc --noEmit` — zero errors
3. `npm run dev` — server starts on PORT 3000
4. `curl http://localhost:3000/health` → `{"status":"ok"}`
5. Browser visit to `/oauth/start` → redirects to launchpad.37signals.com with `type=web_server` in URL
6. Completing Basecamp consent → `/oauth/callback` responds with `{ message: "OAuth complete", user: { basecampUserId, email, accountId } }`
7. `accountId` in the response is a non-empty string (the bc3 account ID from authorization.json)
</verification>

<success_criteria>
- Project has `package.json` with `"type": "module"`, all declared dependencies present
- `tsconfig.json` uses `module: NodeNext`, `strict: true`
- `src/server.ts` exposes `app` and `startServer()`, mounts `/oauth/start`, `/oauth/callback`, `/health`
- `src/auth/oauth.ts` exports `TokenRecord` interface, `startAuthFlow()`, `handleCallback()`
- `handleCallback()` calls `POST launchpad.37signals.com/authorization/token` (code exchange) then `GET launchpad.37signals.com/authorization.json` (identity + account_id resolution)
- Completing a real Basecamp OAuth flow returns a valid `TokenRecord` with all six fields populated
- No token values appear in HTTP responses or server logs
</success_criteria>

<output>
After completion, create `.planning/phases/01-oauth-foundation/01-01-SUMMARY.md` following the summary template.
</output>
