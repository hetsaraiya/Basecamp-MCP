---
phase: 01-oauth-foundation
plan: "02"
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - src/auth/store.ts
  - src/auth/oauth.ts
  - src/server.ts
autonomous: true
requirements:
  - FR-1.4
  - FR-1.5
  - FR-1.6

must_haves:
  truths:
    - "After completing the OAuth flow, the user's TokenRecord is persisted to SQLite — querying the DB confirms the row exists keyed by basecampUserId"
    - "Calling getTokenForUser(userId) on an unexpired token returns the stored accessToken without hitting Basecamp"
    - "Calling getTokenForUser(userId) on a token within 5 minutes of expiry triggers a refresh via POST to launchpad.37signals.com/authorization/token and stores the new tokens before returning"
    - "When Basecamp returns 401, the caller catches a TOKEN_EXPIRED error containing a re-auth URL — this happens only after one refresh attempt has also failed"
    - "GET /oauth/revoke?user_id=<id> calls DELETE https://launchpad.37signals.com/authorization.json with the user's access token and removes the local SQLite row"
    - "Two simultaneous calls to getTokenForUser() for the same user trigger only one refresh request — the second waits for the first's result (per-user mutex)"
  artifacts:
    - path: "src/auth/store.ts"
      provides: "TokenStore class with SQLite-backed read/write/refresh/revoke, per-user mutex"
      exports: ["TokenStore", "TokenExpiredError"]
    - path: "src/auth/oauth.ts"
      provides: "Updated with getTokenForUser() — reads from TokenStore, auto-refreshes, raises TOKEN_EXPIRED on failed refresh"
      exports: ["startAuthFlow", "handleCallback", "getTokenForUser", "TokenRecord"]
    - path: "src/server.ts"
      provides: "Updated /oauth/callback wires TokenStore.save(), adds GET /oauth/revoke endpoint"
      exports: ["app", "startServer"]
  key_links:
    - from: "src/server.ts /oauth/callback"
      to: "src/auth/store.ts TokenStore.save()"
      via: "import TokenStore, call save() after handleCallback()"
      pattern: "TokenStore.*save|store\\.save"
    - from: "src/auth/oauth.ts getTokenForUser()"
      to: "src/auth/store.ts TokenStore.get()"
      via: "reads token, checks expiresAt, calls refreshIfNeeded()"
      pattern: "store\\.get|expiresAt"
    - from: "src/auth/oauth.ts refreshToken()"
      to: "launchpad.37signals.com/authorization/token"
      via: "POST with type=refresh&refresh_token=<token>"
      pattern: "type=refresh|refresh_token"
    - from: "src/server.ts /oauth/revoke"
      to: "launchpad.37signals.com/authorization.json"
      via: "DELETE request with user's access token"
      pattern: "DELETE.*authorization\\.json"
    - from: "src/server.ts /oauth/revoke"
      to: "src/auth/store.ts TokenStore.revoke()"
      via: "import TokenStore, call revoke() after DELETE"
      pattern: "TokenStore.*revoke|store\\.revoke"
---

<objective>
Implement the SQLite token store, complete the token lifecycle (refresh on expiry, TOKEN_EXPIRED error on refresh failure), and add the token revocation endpoint.

Purpose: Plan 01-01 left a `TokenRecord` floating in memory after OAuth. This plan persists it, keeps it valid automatically, and provides a revocation path — making the entire auth layer production-ready for subsequent phases to depend on.

Output: `TokenStore` class backed by SQLite, `getTokenForUser()` with auto-refresh and per-user mutex, `GET /oauth/revoke` endpoint. After this plan, any caller can ask for a user's valid access token without ever thinking about refresh or expiry.
</objective>

<execution_context>
@/home/het/.claude/get-shit-done/workflows/execute-plan.md
@/home/het/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/phases/01-oauth-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: SQLite token store — schema, TokenStore class, per-user mutex</name>
  <files>
    src/auth/store.ts
  </files>
  <action>
Implement `TokenStore` — the SQLite-backed per-user token persistence layer.

**Why better-sqlite3 (not sqlite3 or Prisma):** better-sqlite3 is synchronous, which eliminates async complexity for simple read/write and is significantly simpler to use correctly. It handles concurrent reads fine; writes serialize automatically.

---

**SQLite schema** — create on first open (CREATE TABLE IF NOT EXISTS):

```sql
CREATE TABLE IF NOT EXISTS tokens (
  basecamp_user_id INTEGER PRIMARY KEY,
  access_token     TEXT NOT NULL,
  refresh_token    TEXT NOT NULL,
  expires_at       INTEGER NOT NULL,  -- Unix timestamp (milliseconds)
  account_id       TEXT NOT NULL,
  email            TEXT NOT NULL,
  created_at       INTEGER NOT NULL DEFAULT (unixepoch('now') * 1000),
  updated_at       INTEGER NOT NULL DEFAULT (unixepoch('now') * 1000)
);
```

`expires_at` stored as milliseconds since epoch (matches `Date.getTime()`).

---

**TokenStore class** — implement in `src/auth/store.ts`:

```typescript
import Database from 'better-sqlite3';
import type { TokenRecord } from './oauth.js';

// Per-user mutex: prevents duplicate concurrent refreshes for same user
const refreshMutexes = new Map<number, Promise<TokenRecord>>();

export class TokenExpiredError extends Error {
  readonly code = 'TOKEN_EXPIRED';
  readonly reAuthUrl: string;
  constructor(reAuthUrl: string) {
    super('Basecamp access token expired and refresh failed');
    this.name = 'TokenExpiredError';
    this.reAuthUrl = reAuthUrl;
  }
}

export class TokenStore {
  private db: Database.Database;

  constructor(dbPath: string = process.env.SQLITE_PATH ?? './tokens.db') {
    this.db = new Database(dbPath);
    this.db.pragma('journal_mode = WAL');  // Better concurrent read performance
    this.migrate();
  }

  private migrate() {
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS tokens (
        basecamp_user_id INTEGER PRIMARY KEY,
        access_token     TEXT NOT NULL,
        refresh_token    TEXT NOT NULL,
        expires_at       INTEGER NOT NULL,
        account_id       TEXT NOT NULL,
        email            TEXT NOT NULL,
        created_at       INTEGER NOT NULL DEFAULT (unixepoch('now') * 1000),
        updated_at       INTEGER NOT NULL DEFAULT (unixepoch('now') * 1000)
      );
    `);
  }

  save(record: TokenRecord): void {
    const stmt = this.db.prepare(`
      INSERT INTO tokens (basecamp_user_id, access_token, refresh_token, expires_at, account_id, email, updated_at)
      VALUES (@basecampUserId, @accessToken, @refreshToken, @expiresAt, @accountId, @email, @updatedAt)
      ON CONFLICT(basecamp_user_id) DO UPDATE SET
        access_token  = excluded.access_token,
        refresh_token = excluded.refresh_token,
        expires_at    = excluded.expires_at,
        account_id    = excluded.account_id,
        email         = excluded.email,
        updated_at    = excluded.updated_at
    `);
    stmt.run({
      basecampUserId: record.basecampUserId,
      accessToken: record.accessToken,
      refreshToken: record.refreshToken,
      expiresAt: record.expiresAt.getTime(),
      accountId: record.accountId,
      email: record.email,
      updatedAt: Date.now(),
    });
  }

  get(basecampUserId: number): TokenRecord | null {
    const row = this.db.prepare(
      'SELECT * FROM tokens WHERE basecamp_user_id = ?'
    ).get(basecampUserId) as Record<string, unknown> | undefined;

    if (!row) return null;
    return this.rowToRecord(row);
  }

  revoke(basecampUserId: number): void {
    this.db.prepare('DELETE FROM tokens WHERE basecamp_user_id = ?').run(basecampUserId);
  }

  private rowToRecord(row: Record<string, unknown>): TokenRecord {
    return {
      accessToken: row.access_token as string,
      refreshToken: row.refresh_token as string,
      expiresAt: new Date(row.expires_at as number),
      accountId: row.account_id as string,
      basecampUserId: row.basecamp_user_id as number,
      email: row.email as string,
    };
  }
}

// Singleton — one store per process
export const tokenStore = new TokenStore();
```

**Per-user mutex pattern** — used in Plan 01-02's `getTokenForUser()`:

The mutex map (`refreshMutexes`) ensures that if two concurrent callers both detect an expiring token for the same user, only one refresh HTTP call is made. The second waits for the first's `Promise<TokenRecord>` to resolve and uses that result. Implement this in `oauth.ts` (Task 2) using `refreshMutexes` exported from `store.ts`.

Export `refreshMutexes` from `store.ts` so `oauth.ts` can manage it:
```typescript
export { refreshMutexes };
```
  </action>
  <verify>
1. `npx tsc --noEmit` exits 0 — no errors in store.ts.
2. Run a quick smoke test:
   ```bash
   node --input-type=module <<'EOF'
   import { tokenStore } from './src/auth/store.js';
   const record = {
     accessToken: 'test_access',
     refreshToken: 'test_refresh',
     expiresAt: new Date(Date.now() + 3600000),
     accountId: '12345',
     basecampUserId: 99,
     email: 'test@example.com',
   };
   tokenStore.save(record);
   const fetched = tokenStore.get(99);
   console.log('Fetched:', fetched?.email === 'test@example.com' ? 'PASS' : 'FAIL');
   tokenStore.revoke(99);
   console.log('Revoked:', tokenStore.get(99) === null ? 'PASS' : 'FAIL');
   EOF
   ```
   Both lines print PASS. (Clean up `tokens.db` if created during test.)
3. Verify WAL mode: SQLite file is created at SQLITE_PATH and `PRAGMA journal_mode` returns `wal`.
  </verify>
  <done>
`TokenStore` class exists and exports `tokenStore` singleton, `TokenExpiredError`, and `refreshMutexes`. `save()` upserts a record, `get()` retrieves it with correct types (Date for expiresAt), `revoke()` deletes it. SQLite file is created in WAL mode.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire token store, add getTokenForUser() with auto-refresh, add /oauth/revoke endpoint</name>
  <files>
    src/auth/oauth.ts
    src/server.ts
  </files>
  <action>
Complete the token lifecycle by wiring `TokenStore` into the OAuth flow and adding the `getTokenForUser()` function that all subsequent phases will call. Add the `/oauth/revoke` endpoint.

---

**Update src/auth/oauth.ts** — add `getTokenForUser()` and `refreshTokenForUser()`:

```typescript
import { tokenStore, refreshMutexes, TokenExpiredError } from './store.js';

// How many milliseconds before expiry to proactively refresh (5 minutes)
const REFRESH_BUFFER_MS = 5 * 60 * 1000;

// The re-auth URL shown to callers when refresh fails
const REAUTH_URL = `http://localhost:${process.env.PORT ?? 3000}/oauth/start`;

export async function getTokenForUser(basecampUserId: number): Promise<TokenRecord> {
  const record = tokenStore.get(basecampUserId);
  if (!record) {
    throw new TokenExpiredError(REAUTH_URL);
  }

  // Token still valid with buffer
  if (record.expiresAt.getTime() - Date.now() > REFRESH_BUFFER_MS) {
    return record;
  }

  // Token expiring — use per-user mutex to prevent duplicate refresh calls
  const existing = refreshMutexes.get(basecampUserId);
  if (existing) {
    return existing;
  }

  const refreshPromise = refreshTokenForUser(record).finally(() => {
    refreshMutexes.delete(basecampUserId);
  });
  refreshMutexes.set(basecampUserId, refreshPromise);
  return refreshPromise;
}

async function refreshTokenForUser(record: TokenRecord): Promise<TokenRecord> {
  // Basecamp token refresh: POST with type=refresh query param
  // URL: https://launchpad.37signals.com/authorization/token?type=refresh&refresh_token=<token>&client_id=<id>&client_secret=<secret>
  const params = new URLSearchParams({
    type: 'refresh',
    refresh_token: record.refreshToken,
    client_id: process.env.BASECAMP_CLIENT_ID!,
    client_secret: process.env.BASECAMP_CLIENT_SECRET!,
  });

  let refreshRes: Response;
  try {
    refreshRes = await fetch(
      `https://launchpad.37signals.com/authorization/token?${params.toString()}`,
      { method: 'POST' }
    );
  } catch {
    throw new TokenExpiredError(REAUTH_URL);
  }

  if (!refreshRes.ok) {
    // Refresh failed (e.g., refresh_token revoked) — surface TOKEN_EXPIRED
    throw new TokenExpiredError(REAUTH_URL);
  }

  const body = await refreshRes.json() as {
    access_token: string;
    refresh_token: string;
    expires_in: number;
  };

  const refreshed: TokenRecord = {
    ...record,
    accessToken: body.access_token,
    refreshToken: body.refresh_token,   // Basecamp rotates refresh tokens
    expiresAt: new Date(Date.now() + (body.expires_in ?? 7200) * 1000),
  };

  tokenStore.save(refreshed);  // Atomic upsert — both tokens updated together
  return refreshed;
}
```

**Key constraints on the refresh implementation:**
- Basecamp issues a NEW `refresh_token` on every refresh. Both `access_token` AND `refresh_token` MUST be updated atomically in the store — using only the old refresh_token on the next call will fail.
- If `refreshRes.ok` is false (401, 400), do NOT retry — throw `TokenExpiredError`. The caller must re-authenticate.
- The per-user mutex (`refreshMutexes`) prevents multiple concurrent callers from all triggering separate refresh requests for the same user. Only one refresh Promise runs; others await its result.

**Update handleCallback in oauth.ts** — callers of handleCallback (server.ts) now pass the result to `tokenStore.save()`. No change needed to `handleCallback` itself; `server.ts` wires it.

Export `getTokenForUser` and `TokenExpiredError` from `oauth.ts`. `TokenExpiredError` is re-exported from `store.ts` for convenience — import it from `oauth.ts` in all callers.

---

**Update src/server.ts** — wire TokenStore into /oauth/callback and add /oauth/revoke:

```typescript
import { tokenStore } from './auth/store.js';
import { startAuthFlow, handleCallback, getTokenForUser } from './auth/oauth.js';
import type { TokenExpiredError } from './auth/oauth.js';
```

**Update /oauth/callback** to save the token:
```typescript
app.get('/oauth/callback', async (req, res) => {
  const code = req.query.code as string | undefined;
  if (!code) {
    res.status(400).send('Missing authorization code');
    return;
  }
  try {
    const tokenRecord = await handleCallback(code);
    tokenStore.save(tokenRecord);   // Persist to SQLite
    res.json({
      message: 'OAuth complete — token stored',
      user: {
        basecampUserId: tokenRecord.basecampUserId,
        email: tokenRecord.email,
        accountId: tokenRecord.accountId,
      },
    });
  } catch (err) {
    const message = err instanceof Error ? err.message : 'OAuth callback failed';
    res.status(500).json({ error: message });
  }
});
```

**Add GET /oauth/revoke endpoint:**
```typescript
app.get('/oauth/revoke', async (req, res) => {
  const userIdParam = req.query.user_id as string | undefined;
  const basecampUserId = Number(userIdParam);
  if (!userIdParam || isNaN(basecampUserId)) {
    res.status(400).json({ error: 'Missing or invalid user_id query param' });
    return;
  }

  const record = tokenStore.get(basecampUserId);
  if (!record) {
    res.status(404).json({ error: 'No token found for that user_id' });
    return;
  }

  // Call Basecamp's DELETE /authorization.json to revoke server-side
  // This invalidates the token in Basecamp's system (Pitfall 1.4 prevention)
  try {
    const revokeRes = await fetch('https://launchpad.37signals.com/authorization.json', {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${record.accessToken}`,
        'User-Agent': 'Basecamp MCP (internal@openxcell.com)',
      },
    });
    // 204 = success; 401 = already expired — either way remove locally
    if (!revokeRes.ok && revokeRes.status !== 401) {
      console.warn(`Basecamp revocation returned ${revokeRes.status} for user ${basecampUserId}`);
    }
  } catch (err) {
    // Network error during remote revocation — still remove locally
    console.warn('Remote revocation failed (network), removing local token:', err);
  }

  tokenStore.revoke(basecampUserId);
  res.json({ message: 'Token revoked', basecampUserId });
});
```

**Important notes:**
- `/oauth/revoke` always removes the local token record, even if the Basecamp DELETE call fails (e.g., token already expired). Silently succeeds on 401 from Basecamp.
- Never expose `accessToken` or `refreshToken` in any response body or server log.
- The endpoint uses `user_id` query param (not path param) to keep the URL bookmarkable for team admin use.
  </action>
  <verify>
1. `npx tsc --noEmit` exits 0 — no type errors across server.ts, oauth.ts, store.ts.
2. `npm run dev` starts without errors.
3. Full OAuth flow: visit `/oauth/start` → complete Basecamp consent → `/oauth/callback` returns `{ message: "OAuth complete — token stored", user: { basecampUserId, email, accountId } }`.
4. Confirm SQLite persistence: after completing OAuth, run:
   ```bash
   sqlite3 tokens.db "SELECT basecamp_user_id, email, account_id FROM tokens;"
   ```
   One row exists with the user's data.
5. Test revocation: `curl "http://localhost:3000/oauth/revoke?user_id=<basecampUserId>"` returns `{ message: "Token revoked", basecampUserId: <id> }`.
6. After revocation: `sqlite3 tokens.db "SELECT * FROM tokens;"` — zero rows.
7. Test getTokenForUser error path: after revocation, any code calling `getTokenForUser(<id>)` should throw `TokenExpiredError` (test with a small Node script importing and calling the function).
  </verify>
  <done>
Completing a real Basecamp OAuth flow persists the TokenRecord to SQLite. `GET /oauth/revoke?user_id=<id>` calls `DELETE https://launchpad.37signals.com/authorization.json` and removes the local row. `getTokenForUser()` returns the stored token when valid, triggers a proactive refresh when within 5 minutes of expiry, and throws `TokenExpiredError` with a re-auth URL when no token exists or refresh fails. The per-user mutex ensures no duplicate refresh calls for concurrent requests.
  </done>
</task>

</tasks>

<verification>
Full Phase 1 verification — run after both plans complete:

1. `npx tsc --noEmit` exits 0.
2. `npm run dev` starts server without errors.
3. **OAuth flow**: visit `/oauth/start` → Basecamp consent → `/oauth/callback` → JSON response with user info.
4. **Persistence**: `sqlite3 tokens.db "SELECT basecamp_user_id, email, account_id, expires_at FROM tokens;"` shows the authenticated user's row.
5. **Auto-refresh smoke test**: In a Node REPL with tsx:
   ```typescript
   import { getTokenForUser } from './src/auth/oauth.js';
   const record = await getTokenForUser(<your_basecampUserId>);
   console.log(record.email, record.accountId);  // Prints without error
   ```
6. **Revocation**: `curl "http://localhost:3000/oauth/revoke?user_id=<id>"` → `{ message: "Token revoked" }`. Querying SQLite shows zero rows.
7. **Post-revocation error**: `getTokenForUser(<id>)` throws `TokenExpiredError` with `code: 'TOKEN_EXPIRED'` and `reAuthUrl` containing `/oauth/start`.
</verification>

<success_criteria>
Phase 1 is complete when ALL of the following are true:

1. A team member visits `/oauth/start`, completes the Basecamp Launchpad flow, and has their `TokenRecord` stored in SQLite
2. `sqlite3 tokens.db "SELECT * FROM tokens;"` shows a row with `access_token`, `refresh_token`, `expires_at`, `account_id`, `email`, and `basecamp_user_id`
3. `getTokenForUser(userId)` returns a valid access token for authenticated users without re-prompting
4. `getTokenForUser(userId)` for a user with no stored token throws `TokenExpiredError` with `reAuthUrl` set
5. `GET /oauth/revoke?user_id=<id>` removes the local token and calls `DELETE /authorization.json` on Basecamp
6. `npx tsc --noEmit` exits 0 — the entire codebase is type-safe
</success_criteria>

<output>
After completion, create `.planning/phases/01-oauth-foundation/01-02-SUMMARY.md` following the summary template.
</output>
