---
phase: 03-mcp-tool-definitions
plan: "02"
type: execute
wave: 2
depends_on:
  - "03-01"
files_modified:
  - src/tools/tools.ts
  - src/mcp.ts
  - package.json
autonomous: false
requirements:
  - FR-5.1
  - FR-5.2
  - FR-5.3
  - FR-6.1
  - FR-6.2
  - FR-6.3
  - FR-7.1
  - FR-7.2
  - FR-8.1
  - FR-8.2

user_setup:
  - service: basecamp-inspector
    why: "MCP Inspector testing requires a real authenticated Basecamp user ID"
    env_vars:
      - name: BASECAMP_TEST_USER_ID
        source: "From the SQLite tokens.db — query: sqlite3 tokens.db 'SELECT basecamp_user_id FROM tokens LIMIT 1;' after completing OAuth at /oauth/start"

must_haves:
  truths:
    - "MCP Inspector lists all 11 tools with correct names, descriptions, and input schemas"
    - "list_campfire_lines called without since or limit returns the last 24 hours of messages"
    - "list_documents returns truncated content (first 500 chars) with truncated:true flag"
    - "get_document returns full document content as markdown"
    - "list_attachments returns metadata only — id, filename, content_type, byte_size, download_url, creator name, created_at"
    - "src/mcp.ts starts without error when BASECAMP_TEST_USER_ID is set"
    - "list_projects called from MCP Inspector returns real Basecamp projects"
  artifacts:
    - path: "src/mcp.ts"
      provides: "Standalone stdio MCP entry point using StdioServerTransport"
      contains: "StdioServerTransport"
    - path: "src/tools/tools.ts"
      provides: "Complete createTools() factory with all 11 tools"
      exports: ["createTools"]
  key_links:
    - from: "src/mcp.ts"
      to: "src/tools/tools.ts"
      via: "createTools(userId, tokenStore) called with userId from BASECAMP_TEST_USER_ID env var"
      pattern: "createTools\\(userId"
    - from: "src/mcp.ts"
      to: "@modelcontextprotocol/sdk/server/stdio.js"
      via: "new StdioServerTransport() connected to McpServer from createTools()"
      pattern: "StdioServerTransport"
    - from: "list_campfire_lines handler"
      to: "BasecampClient.listCampfireLines()"
      via: "since defaults to new Date(Date.now() - 24*60*60*1000).toISOString() when neither since nor limit provided"
      pattern: "24.*60.*60.*1000"
---

<objective>
Add the 4 remaining MCP tools (list_documents, get_document, list_campfire_lines, list_attachments) to the createTools() factory, create the src/mcp.ts stdio entry point, and verify all 11 tools are callable in MCP Inspector.

Purpose: Completes the tool surface. The stdio entry point enables MCP Inspector testing without a live HTTP transport — a failing tool is identifiable as a tool problem, not a transport problem (per ROADMAP "Why this order").

Output: src/tools/tools.ts with 11 tools, src/mcp.ts stdio entry point, MCP Inspector smoke test
</objective>

<execution_context>
@/home/het/.claude/get-shit-done/workflows/execute-plan.md
@/home/het/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/tools/tools.ts
@src/tools/errors.ts
@src/client/BasecampClient.ts
@src/client/schemas/index.ts
@src/auth/store.ts
@.planning/phases/03-mcp-tool-definitions/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add 4 remaining tools to createTools() and create src/mcp.ts</name>
  <files>src/tools/tools.ts, src/mcp.ts, package.json</files>
  <action>
**Step 1 — Add 4 remaining tools to src/tools/tools.ts:**

Open `src/tools/tools.ts`. Inside the `createTools()` function, after the `get_todo` registration block and before `return server;`, add the following four tool registrations:

```typescript
  // -------------------------------------------------------------------------
  // list_documents — FR-5.1, FR-5.3
  // -------------------------------------------------------------------------
  server.tool(
    'list_documents',
    'List documents in a Basecamp project vault. Returns document titles, authors, creation dates, and a preview of the content (first 500 characters). Use get_document to fetch the full content of a specific document. Get vault_id from get_project_tools first.',
    {
      project_id: z.number().int().positive().describe('The Basecamp project ID'),
      vault_id: z.number().int().positive().describe('The vault ID from get_project_tools'),
      page: z.number().int().positive().optional().default(1).describe('Page number for pagination'),
    },
    async ({ project_id, vault_id, page }) => {
      try {
        const record = tokenStore.get(userId);
        if (!record) return toolError('TOKEN_EXPIRED', 'No token found for user. Re-authenticate at /oauth/start', false);
        const client = new BasecampClient({ accessToken: record.accessToken, accountId: record.accountId });
        const result = await client.listDocuments(project_id, vault_id, page);
        // DocumentSummarySchema already truncates content to 500 chars and sets truncated:true (NFR-4.3)
        return toolSuccess(result);
      } catch (error) {
        return classifyError(error);
      }
    },
  );

  // -------------------------------------------------------------------------
  // get_document — FR-5.2, FR-5.3
  // -------------------------------------------------------------------------
  server.tool(
    'get_document',
    'Get a single Basecamp document with full content as markdown. Returns the document title, author (name and email), creation date, last update date, and the complete document body converted to markdown. Use document IDs from list_documents.',
    {
      project_id: z.number().int().positive().describe('The Basecamp project ID'),
      document_id: z.number().int().positive().describe('The document ID from list_documents'),
    },
    async ({ project_id, document_id }) => {
      try {
        const record = tokenStore.get(userId);
        if (!record) return toolError('TOKEN_EXPIRED', 'No token found for user. Re-authenticate at /oauth/start', false);
        const client = new BasecampClient({ accessToken: record.accessToken, accountId: record.accountId });
        const document = await client.getDocument(project_id, document_id);
        return toolSuccess(document);
      } catch (error) {
        return classifyError(error);
      }
    },
  );

  // -------------------------------------------------------------------------
  // list_campfire_lines — FR-6.1, FR-6.2, FR-6.3
  // -------------------------------------------------------------------------
  server.tool(
    'list_campfire_lines',
    'List chat messages from a Basecamp Campfire room. Returns messages with author names, timestamps, and content as markdown. Defaults to the last 24 hours if neither since nor limit is specified. Get chat_id from get_project_tools first.',
    {
      project_id: z.number().int().positive().describe('The Basecamp project ID'),
      chat_id: z.number().int().positive().describe('The Campfire chat ID from get_project_tools'),
      since: z.string().optional().describe(
        'ISO 8601 datetime — return only lines created after this time. Example: "2026-01-15T09:00:00Z". If omitted and limit is also omitted, defaults to 24 hours ago.'
      ),
      limit: z.number().int().min(1).max(200).optional().describe(
        'Maximum number of recent lines to return (1-200). If omitted and since is also omitted, defaults to last 24 hours.'
      ),
      page: z.number().int().positive().optional().default(1).describe('Page number for pagination'),
    },
    async ({ project_id, chat_id, since, limit, page }) => {
      try {
        const record = tokenStore.get(userId);
        if (!record) return toolError('TOKEN_EXPIRED', 'No token found for user. Re-authenticate at /oauth/start', false);
        const client = new BasecampClient({ accessToken: record.accessToken, accountId: record.accountId });

        // FR-6.2: Default to last 24 hours when neither since nor limit is provided
        const effectiveSince = since ?? (limit == null
          ? new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString()
          : undefined);

        const result = await client.listCampfireLines(project_id, chat_id, page);

        // Apply since filter client-side (Basecamp API does not support since param on chat lines)
        let items = result.items;
        if (effectiveSince) {
          const sinceMs = new Date(effectiveSince).getTime();
          items = items.filter((line) => new Date(line.created_at).getTime() >= sinceMs);
        }
        // Apply limit (take last N items after since filter)
        if (limit != null) {
          items = items.slice(-limit);
        }

        return toolSuccess({ ...result, items, since: effectiveSince ?? null });
      } catch (error) {
        return classifyError(error);
      }
    },
  );

  // -------------------------------------------------------------------------
  // list_attachments — FR-7.1, FR-7.2
  // -------------------------------------------------------------------------
  server.tool(
    'list_attachments',
    'List file attachments in a Basecamp project vault. Returns metadata only — filename, content type, file size in bytes, a download URL, uploader name, and creation date. Binary content is never fetched. Get vault_id from get_project_tools first.',
    {
      project_id: z.number().int().positive().describe('The Basecamp project ID'),
      vault_id: z.number().int().positive().describe('The vault ID from get_project_tools'),
      page: z.number().int().positive().optional().default(1).describe('Page number for pagination'),
    },
    async ({ project_id, vault_id, page }) => {
      try {
        const record = tokenStore.get(userId);
        if (!record) return toolError('TOKEN_EXPIRED', 'No token found for user. Re-authenticate at /oauth/start', false);
        const client = new BasecampClient({ accessToken: record.accessToken, accountId: record.accountId });
        const result = await client.listAttachments(project_id, vault_id, page);
        // Map to metadata-only shape per FR-7.2
        const items = result.items.map((a) => ({
          id: a.id,
          filename: a.title,     // AttachmentSchema maps filename->title; reverse for agent clarity
          content_type: a.content_type,
          byte_size: a.byte_size,
          download_url: a.download_url ?? null,
          creator: a.author.name,
          created_at: a.created_at,
        }));
        return toolSuccess({ ...result, items });
      } catch (error) {
        return classifyError(error);
      }
    },
  );
```

**Step 2 — Create src/mcp.ts:**

```typescript
/**
 * mcp.ts — Standalone MCP server entry point using StdioServerTransport.
 *
 * Phase 3 usage: MCP Inspector testing.
 *   npx tsx src/mcp.ts
 *
 * Reads userId from BASECAMP_TEST_USER_ID env var (integer).
 * Phase 4 will replace this with per-session userId from the HTTP URL path.
 *
 * Architecture decision (STATE.md 2026-02-19):
 *   StdioServerTransport for Phase 3 (Inspector testing).
 *   StreamableHTTPServerTransport is Phase 4 concern.
 *
 * SDK version decision (STATE.md 2026-02-19):
 *   @modelcontextprotocol/sdk ^1.15.0 required (not ^1.6.x from stale ROADMAP stack line).
 */

import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { tokenStore } from './auth/store.js';
import { createTools } from './tools/tools.js';

async function main() {
  const userIdEnv = process.env['BASECAMP_TEST_USER_ID'];
  if (!userIdEnv) {
    console.error(
      'Error: BASECAMP_TEST_USER_ID environment variable is required.\n' +
      'Set it to your Basecamp user ID from the tokens.db:\n' +
      '  sqlite3 tokens.db "SELECT basecamp_user_id FROM tokens LIMIT 1;"\n' +
      'Then run:\n' +
      '  BASECAMP_TEST_USER_ID=<id> npx tsx src/mcp.ts'
    );
    process.exit(1);
  }

  const userId = parseInt(userIdEnv, 10);
  if (isNaN(userId)) {
    console.error(`Error: BASECAMP_TEST_USER_ID must be an integer. Got: "${userIdEnv}"`);
    process.exit(1);
  }

  const server = createTools(userId, tokenStore);
  const transport = new StdioServerTransport();
  await server.connect(transport);

  // Keep process alive — stdio transport reads from stdin
  process.on('SIGINT', async () => {
    await server.close();
    process.exit(0);
  });
}

main().catch((error) => {
  console.error('MCP server failed to start:', error);
  process.exit(1);
});
```

**Step 3 — Update package.json scripts:**

In `package.json`, add a `mcp` script alongside the existing scripts:

```json
"scripts": {
  "dev": "tsx watch src/server.ts",
  "build": "tsc",
  "start": "node dist/server.js",
  "mcp": "tsx src/mcp.ts"
}
```

**Step 4 — Compile:**

Run: `npx tsc --noEmit`

Expected: zero errors. If StdioServerTransport import fails, confirm the import path: in SDK ^1.15.0 it is `@modelcontextprotocol/sdk/server/stdio.js` (note the `.js` extension, required by NodeNext moduleResolution).
  </action>
  <verify>
1. `npx tsc --noEmit` exits 0
2. `grep -c "server.tool(" src/tools/tools.ts` outputs `11`
3. `ls src/mcp.ts` confirms file exists
4. `grep "StdioServerTransport\|createTools" src/mcp.ts` shows both imports
5. `grep "mcp" package.json` shows the mcp script
  </verify>
  <done>
src/tools/tools.ts has 11 tool registrations. src/mcp.ts exists with StdioServerTransport and createTools import. tsc compiles clean. package.json has "mcp" script.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: MCP Inspector verification — all 11 tools callable against real Basecamp data</name>
  <action>
Prerequisites before running Inspector:
1. OAuth token must be stored: run `npm run dev` and visit http://localhost:3000/oauth/start to authenticate
2. Find your userId: `sqlite3 tokens.db "SELECT basecamp_user_id FROM tokens LIMIT 1;"`
3. Set env var and start MCP server: `BASECAMP_TEST_USER_ID=&lt;your-id&gt; npm run mcp`
4. Open MCP Inspector: `npx @modelcontextprotocol/inspector` and connect to the running stdio process
  </action>
  <verify>
In MCP Inspector:
1. Tools list shows exactly 11 tools with correct names (list_projects, get_project_tools, list_messages, get_message, list_todolists, list_todos, get_todo, list_documents, get_document, list_campfire_lines, list_attachments)
2. Call list_projects (no arguments) — returns real Basecamp projects with id, name, description, status fields
3. Call get_project_tools with a project_id from step 2 — returns numeric message_board_id, todoset_id, vault_id, chat_id
4. Call list_campfire_lines with project_id and chat_id but NO since and NO limit — response includes a "since" field set to a time 24 hours ago
5. Call list_documents with project_id and vault_id — items have truncated:true flag
  </verify>
  <done>
MCP Inspector lists all 11 tools. list_projects returns real Basecamp projects. get_project_tools returns dock IDs. list_campfire_lines defaults to 24h window. All tool responses are JSON-in-text content blocks with no raw HTML.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `grep -c "server.tool(" src/tools/tools.ts` outputs 11
- `ls src/mcp.ts` confirms entry point exists
- MCP Inspector lists all 11 tools
- list_projects returns real Basecamp data
- list_campfire_lines defaults to 24h window when called without since or limit
</verification>

<success_criteria>
1. All 11 tools registered in createTools() — confirmed by grep count of 11
2. src/mcp.ts starts with BASECAMP_TEST_USER_ID set, connects StdioServerTransport, stays alive
3. MCP Inspector lists all 11 tools with correct names, descriptions, and input schemas (FR-8.1, FR-8.2)
4. list_projects returns real Basecamp projects via MCP Inspector (Phase 3 success criterion #2)
5. list_campfire_lines called without since or limit returns only last-24h messages (FR-6.2)
6. list_documents response includes truncated:true for content preview (FR-5.1)
7. list_attachments returns metadata-only — no content field, just filename/type/size/url (FR-7.2)
</success_criteria>

<output>
After completion, create `.planning/phases/03-mcp-tool-definitions/03-02-SUMMARY.md`
</output>
