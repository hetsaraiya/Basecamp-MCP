---
phase: 03-mcp-tool-definitions
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - package-lock.json
  - src/client/BasecampClient.ts
  - src/tools/errors.ts
  - src/tools/tools.ts
autonomous: true
requirements:
  - FR-2.1
  - FR-2.2
  - FR-2.3
  - FR-2.4
  - FR-3.1
  - FR-3.2
  - FR-3.3
  - FR-3.4
  - FR-4.1
  - FR-4.2
  - FR-4.3
  - FR-4.4
  - FR-8.1
  - FR-8.2
  - FR-8.3
  - FR-8.4

must_haves:
  truths:
    - "list_projects returns all accessible Basecamp projects with id, name, description, status, and active dock tool types"
    - "get_project_tools returns message_board_id, todoset_id, vault_id, chat_id without requiring those IDs as agent inputs"
    - "list_messages, list_todolists, list_todos, get_todo all require only project_id (plus content-specific IDs) — never internal dock IDs"
    - "get_message returns body in markdown (no raw HTML)"
    - "Any tool call with missing required input returns { isError: true, content: [{ type: 'text', text: '...' }] } with an error_code field"
  artifacts:
    - path: "src/tools/errors.ts"
      provides: "Typed MCP error builder — toolError(code, message, retryable)"
      exports: ["toolError", "ToolErrorCode"]
    - path: "src/tools/tools.ts"
      provides: "createTools() factory returning list_projects, get_project_tools, list_messages, get_message, list_todolists, list_todos, get_todo registered on McpServer"
      exports: ["createTools"]
    - path: "src/client/BasecampClient.ts"
      provides: "getProject(projectId) method returning raw project JSON with dock array"
      contains: "getProject"
  key_links:
    - from: "src/tools/tools.ts"
      to: "src/client/BasecampClient.ts"
      via: "createTools(userId, tokenStore) constructs BasecampClient from tokenStore.get(userId)"
      pattern: "tokenStore\\.get\\(userId\\)"
    - from: "src/tools/tools.ts"
      to: "src/tools/errors.ts"
      via: "all tool handlers call toolError() on catch"
      pattern: "toolError\\("
    - from: "get_project_tools handler"
      to: "BasecampClient.getProject()"
      via: "dock.find(d => d.name === 'message_board') etc. per decided dock.name field"
      pattern: "d\\.name === 'message_board'"
---

<objective>
Install MCP SDK, add getProject() to BasecampClient, create the typed error module, and implement the first 7 MCP tools (list_projects, get_project_tools, list_messages, get_message, list_todolists, list_todos, get_todo) via a createTools() factory.

Purpose: These 7 tools cover the core project navigation and content-reading workflows that agents need most. The createTools() factory pattern (decided in CRITICAL DECISIONS) allows Phase 4 to bind per-session user IDs without any tool-layer changes.

Output: src/tools/errors.ts, src/tools/tools.ts (7 tools), BasecampClient.getProject(), @modelcontextprotocol/sdk installed
</objective>

<execution_context>
@/home/het/.claude/get-shit-done/workflows/execute-plan.md
@/home/het/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/client/BasecampClient.ts
@src/client/schemas/index.ts
@src/client/paginate.ts
@src/auth/store.ts
@src/client/types.ts
@.planning/phases/02-api-client-infrastructure/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install MCP SDK and add getProject() to BasecampClient</name>
  <files>package.json, package-lock.json, src/client/BasecampClient.ts</files>
  <action>
**Step 1 — Install MCP SDK:**

Run: `npm install @modelcontextprotocol/sdk@^1.15.0`

This installs the MCP SDK at ^1.15.0 (NOT the stale ^1.6.x in ROADMAP.md stack line — ^1.15.0 is the minimum required for authInfo passthrough in StreamableHTTPServerTransport). Confirm it appears in package.json dependencies.

**Step 2 — Add getProject() to BasecampClient:**

In `src/client/BasecampClient.ts`, add a new public method after the existing `listAttachments` method:

```typescript
/**
 * getProject — returns the raw Basecamp project JSON including the dock array.
 *
 * Used by MCP tools to resolve dock-internal IDs (message_board_id, todoset_id,
 * vault_id, chat_id) without requiring the agent to supply them (FR-2.4).
 *
 * The dock array items have shape: { id, title, name, enabled, position, url, app_url }
 * where `name` is the dock tool type key. Correct name values:
 *   'message_board', 'todoset', 'vault', 'chat', 'schedule', 'questionnaire'
 * NOT the Ruby class names ('Message::Board' etc.) — confirmed 2026-02-19.
 */
async getProject(projectId: number): Promise<{
  id: number;
  name: string;
  description: string;
  status: string;
  created_at: string;
  updated_at: string;
  dock: Array<{
    id: number;
    title: string;
    name: string;
    enabled: boolean;
    position: number;
    url: string;
    app_url: string;
  }>;
}> {
  return this.get(`projects/${projectId}.json`);
}
```

Note: `this.get<T>()` already handles rate limiting and concurrency. No additional wrapping needed.

**Step 3 — Verify TypeScript compiles:**

Run: `npx tsc --noEmit`

Fix any type errors before proceeding.
  </action>
  <verify>
1. `cat package.json | grep modelcontextprotocol` shows `"@modelcontextprotocol/sdk": "^1.15.0"` in dependencies
2. `npx tsc --noEmit` exits 0 with no errors
3. `grep -n "getProject" src/client/BasecampClient.ts` shows the new method
  </verify>
  <done>
@modelcontextprotocol/sdk ^1.15.0 in package.json dependencies, getProject() method on BasecampClient returns typed project+dock object, tsc compiles clean
  </done>
</task>

<task type="auto">
  <name>Task 2: Create typed error module and createTools() factory with 7 tools</name>
  <files>src/tools/errors.ts, src/tools/tools.ts</files>
  <action>
**Step 1 — Create src/tools/errors.ts:**

```typescript
/**
 * errors.ts — Typed MCP error responses for all tool handlers.
 *
 * MCP tool errors are returned as successful MCP responses (not thrown)
 * with isError: true and a structured content block. This lets agents
 * read the error_code and decide whether to retry or surface to user.
 * (FR-8.3, FR-8.4)
 */

export type ToolErrorCode =
  | 'TOKEN_EXPIRED'
  | 'RATE_LIMITED'
  | 'NOT_FOUND'
  | 'TOOL_NOT_ENABLED'
  | 'PERMISSION_DENIED'
  | 'INVALID_INPUT';

export interface ToolErrorPayload {
  error_code: ToolErrorCode;
  message: string;
  retryable: boolean;
}

/**
 * toolError — builds a structured MCP error response envelope.
 *
 * Returns the shape expected by McpServer tool handlers:
 *   { isError: true, content: [{ type: 'text', text: JSON.stringify(payload) }] }
 */
export function toolError(
  code: ToolErrorCode,
  message: string,
  retryable = false,
): { isError: true; content: Array<{ type: 'text'; text: string }> } {
  const payload: ToolErrorPayload = { error_code: code, message, retryable };
  return {
    isError: true,
    content: [{ type: 'text', text: JSON.stringify(payload) }],
  };
}

/**
 * toolSuccess — wraps a plain object as a successful MCP content envelope.
 *
 * All tool handlers return content blocks with type 'text' containing JSON.
 */
export function toolSuccess(
  data: unknown,
): { content: Array<{ type: 'text'; text: string }> } {
  return {
    content: [{ type: 'text', text: JSON.stringify(data, null, 2) }],
  };
}

/**
 * classifyError — maps known error types to ToolErrorCode.
 *
 * Called in every tool handler's catch block to translate BasecampClient
 * errors (RateLimitError, TokenExpiredError, HTTP 404s) into typed codes.
 */
export function classifyError(error: unknown): ReturnType<typeof toolError> {
  if (error instanceof Error) {
    // TokenExpiredError from src/auth/store.ts
    if ('code' in error && (error as { code: string }).code === 'TOKEN_EXPIRED') {
      return toolError('TOKEN_EXPIRED', error.message, false);
    }
    // RateLimitError from src/client/types.ts
    if (error.constructor.name === 'RateLimitError') {
      return toolError('RATE_LIMITED', error.message, true);
    }
    // got HTTP errors — check statusCode
    if ('response' in error) {
      const resp = (error as { response: { statusCode: number } }).response;
      if (resp?.statusCode === 404) {
        return toolError('NOT_FOUND', error.message, false);
      }
      if (resp?.statusCode === 403) {
        return toolError('PERMISSION_DENIED', error.message, false);
      }
    }
  }
  return toolError('NOT_FOUND', String(error), false);
}
```

**Step 2 — Create src/tools/tools.ts:**

```typescript
/**
 * tools.ts — createTools() factory for all Phase 3 MCP tools.
 *
 * Architecture decision (STATE.md 2026-02-19):
 *   createTools(userId, tokenStore) is called once per MCP session.
 *   Phase 3 uses BASECAMP_TEST_USER_ID env var; Phase 4 passes per-session userId.
 *   The McpServer instance is created inside this factory and returned for transport wiring.
 *
 * Tool pattern:
 *   1. Parse and validate inputs with zod (z.object inputSchema)
 *   2. Call tokenStore.get(userId) to obtain credentials
 *   3. Construct BasecampClient(credentials)
 *   4. Call the appropriate client method
 *   5. Return toolSuccess(result) or classifyError(error)
 *
 * Dock lookup pattern (FR-2.4, decided 2026-02-19):
 *   Tools that need internal Basecamp IDs call client.getProject(projectId)
 *   and find dock items by `name` field (NOT `type`). Values: 'message_board',
 *   'todoset', 'vault', 'chat'. A disabled dock item returns TOOL_NOT_ENABLED.
 */

import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import { BasecampClient } from '../client/BasecampClient.js';
import { TokenStore } from '../auth/store.js';
import { toolError, toolSuccess, classifyError } from './errors.js';

// ---------------------------------------------------------------------------
// Dock lookup helper
// ---------------------------------------------------------------------------

/**
 * findDockItem — resolves a dock tool's internal Basecamp ID from the project dock.
 *
 * Returns { id, url } for the dock item with the given name, or null if not found
 * or not enabled. Callers check for null and return TOOL_NOT_ENABLED.
 *
 * dock.name values: 'message_board', 'todoset', 'vault', 'chat'
 */
function findDockItem(
  dock: Array<{ id: number; name: string; enabled: boolean; url: string }>,
  name: string,
): { id: number; url: string } | null {
  const item = dock.find((d) => d.name === name);
  if (!item || !item.enabled) return null;
  return { id: item.id, url: item.url };
}

// ---------------------------------------------------------------------------
// Factory
// ---------------------------------------------------------------------------

export function createTools(userId: number, tokenStore: TokenStore): McpServer {
  const server = new McpServer({
    name: 'basecamp-mcp',
    version: '1.0.0',
  });

  // -------------------------------------------------------------------------
  // list_projects — FR-2.1, FR-2.2, FR-2.3
  // -------------------------------------------------------------------------
  server.tool(
    'list_projects',
    'List all Basecamp projects accessible to the authenticated user. Returns project IDs, names, descriptions, statuses, and which tools (messages, todos, docs, campfire) are active in each project. Use project_id from results to call other tools.',
    {
      status: z.enum(['active', 'archived', 'all']).optional().default('active').describe(
        'Filter by project status. "active" (default) returns only active projects. "archived" returns archived only. "all" returns both.'
      ),
      page: z.number().int().positive().optional().default(1).describe(
        'Page number for pagination. Check has_more in response to determine if more pages exist.'
      ),
    },
    async ({ status, page }) => {
      try {
        const record = tokenStore.get(userId);
        if (!record) return toolError('TOKEN_EXPIRED', 'No token found for user. Re-authenticate at /oauth/start', false);
        const client = new BasecampClient({ accessToken: record.accessToken, accountId: record.accountId });
        const result = await client.listProjects(page);
        // Apply status filter (Basecamp API returns all statuses, we filter client-side for 'active'/'archived')
        const items = status === 'all'
          ? result.items
          : result.items.filter((p) => p.status === (status === 'active' ? 'active' : 'archived'));
        return toolSuccess({ ...result, items });
      } catch (error) {
        return classifyError(error);
      }
    },
  );

  // -------------------------------------------------------------------------
  // get_project_tools — FR-2.4
  // -------------------------------------------------------------------------
  server.tool(
    'get_project_tools',
    'Get the internal tool IDs for a Basecamp project. Returns message_board_id, todoset_id, vault_id, and chat_id needed to call content tools. Also shows which tools are currently enabled. Always call this before calling list_messages, list_todolists, list_documents, or list_campfire_lines for a project you have not queried before.',
    {
      project_id: z.number().int().positive().describe('The Basecamp project ID from list_projects'),
    },
    async ({ project_id }) => {
      try {
        const record = tokenStore.get(userId);
        if (!record) return toolError('TOKEN_EXPIRED', 'No token found for user. Re-authenticate at /oauth/start', false);
        const client = new BasecampClient({ accessToken: record.accessToken, accountId: record.accountId });
        const project = await client.getProject(project_id);
        // Build a clean map of dock tool names → their IDs and enabled status
        const tools: Record<string, { id: number; enabled: boolean; url: string }> = {};
        for (const item of project.dock) {
          tools[item.name] = { id: item.id, enabled: item.enabled, url: item.app_url };
        }
        return toolSuccess({
          project_id: project.id,
          project_name: project.name,
          message_board_id: tools['message_board']?.id ?? null,
          todoset_id: tools['todoset']?.id ?? null,
          vault_id: tools['vault']?.id ?? null,
          chat_id: tools['chat']?.id ?? null,
          tools,
        });
      } catch (error) {
        return classifyError(error);
      }
    },
  );

  // -------------------------------------------------------------------------
  // list_messages — FR-3.1, FR-3.3, FR-3.4
  // -------------------------------------------------------------------------
  server.tool(
    'list_messages',
    'List message board posts in a Basecamp project. Returns message subjects, authors, creation dates, and content as markdown. Get message_board_id from get_project_tools first.',
    {
      project_id: z.number().int().positive().describe('The Basecamp project ID'),
      message_board_id: z.number().int().positive().describe('The message board ID from get_project_tools'),
      page: z.number().int().positive().optional().default(1).describe('Page number for pagination'),
    },
    async ({ project_id, message_board_id, page }) => {
      try {
        const record = tokenStore.get(userId);
        if (!record) return toolError('TOKEN_EXPIRED', 'No token found for user. Re-authenticate at /oauth/start', false);
        const client = new BasecampClient({ accessToken: record.accessToken, accountId: record.accountId });
        const result = await client.listMessages(project_id, message_board_id, page);
        return toolSuccess(result);
      } catch (error) {
        return classifyError(error);
      }
    },
  );

  // -------------------------------------------------------------------------
  // get_message — FR-3.2, FR-3.3, FR-3.4
  // -------------------------------------------------------------------------
  server.tool(
    'get_message',
    'Get a single Basecamp message board post with full content as markdown. Returns the message subject, author (name and email), creation date, and the full post body converted to markdown. Use message IDs from list_messages.',
    {
      project_id: z.number().int().positive().describe('The Basecamp project ID'),
      message_id: z.number().int().positive().describe('The message ID from list_messages'),
    },
    async ({ project_id, message_id }) => {
      try {
        const record = tokenStore.get(userId);
        if (!record) return toolError('TOKEN_EXPIRED', 'No token found for user. Re-authenticate at /oauth/start', false);
        const client = new BasecampClient({ accessToken: record.accessToken, accountId: record.accountId });
        // get_message fetches a single message — no paginate, direct GET
        const raw = await client.get<Record<string, unknown>>(
          `buckets/${project_id}/messages/${message_id}.json`
        );
        const { htmlToMarkdown } = await import('../client/html-to-markdown.js');
        const { MessageSchema } = await import('../client/schemas/index.js');
        const message = MessageSchema.parse({
          id: raw['id'],
          title: raw['subject'],
          author: raw['creator'],
          created_at: raw['created_at'],
          updated_at: raw['updated_at'],
          url: raw['app_url'],
          content: htmlToMarkdown(raw['content'] as string),
        });
        return toolSuccess(message);
      } catch (error) {
        return classifyError(error);
      }
    },
  );

  // -------------------------------------------------------------------------
  // list_todolists — FR-4.1
  // -------------------------------------------------------------------------
  server.tool(
    'list_todolists',
    'List to-do lists in a Basecamp project. Returns list names, descriptions, and item counts. Get todoset_id from get_project_tools first. Use todolist IDs from results to call list_todos.',
    {
      project_id: z.number().int().positive().describe('The Basecamp project ID'),
      todoset_id: z.number().int().positive().describe('The todoset ID from get_project_tools'),
      page: z.number().int().positive().optional().default(1).describe('Page number for pagination'),
    },
    async ({ project_id, todoset_id, page }) => {
      try {
        const record = tokenStore.get(userId);
        if (!record) return toolError('TOKEN_EXPIRED', 'No token found for user. Re-authenticate at /oauth/start', false);
        const client = new BasecampClient({ accessToken: record.accessToken, accountId: record.accountId });
        const result = await client.listTodoLists(project_id, todoset_id, page);
        return toolSuccess(result);
      } catch (error) {
        return classifyError(error);
      }
    },
  );

  // -------------------------------------------------------------------------
  // list_todos — FR-4.2, FR-4.4
  // -------------------------------------------------------------------------
  server.tool(
    'list_todos',
    'List to-do items in a specific to-do list. Returns todo titles, descriptions as markdown, assignees, due dates, and completion status. Use todolist_id from list_todolists.',
    {
      project_id: z.number().int().positive().describe('The Basecamp project ID'),
      todolist_id: z.number().int().positive().describe('The to-do list ID from list_todolists'),
      completed: z.boolean().optional().default(false).describe(
        'If false (default), returns only incomplete todos. If true, returns completed todos.'
      ),
      page: z.number().int().positive().optional().default(1).describe('Page number for pagination'),
    },
    async ({ project_id, todolist_id, completed, page }) => {
      try {
        const record = tokenStore.get(userId);
        if (!record) return toolError('TOKEN_EXPIRED', 'No token found for user. Re-authenticate at /oauth/start', false);
        const client = new BasecampClient({ accessToken: record.accessToken, accountId: record.accountId });
        // listTodos fetches all todos; filter by completed status client-side
        const result = await client.listTodos(project_id, todolist_id, page);
        const items = result.items.filter((t) => t.completed === completed);
        return toolSuccess({ ...result, items });
      } catch (error) {
        return classifyError(error);
      }
    },
  );

  // -------------------------------------------------------------------------
  // get_todo — FR-4.3, FR-4.4
  // -------------------------------------------------------------------------
  server.tool(
    'get_todo',
    'Get a single Basecamp to-do item with full detail. Returns the todo title, description as markdown, assignees with names and emails, due date, completion status, and creation date.',
    {
      project_id: z.number().int().positive().describe('The Basecamp project ID'),
      todo_id: z.number().int().positive().describe('The to-do item ID from list_todos'),
    },
    async ({ project_id, todo_id }) => {
      try {
        const record = tokenStore.get(userId);
        if (!record) return toolError('TOKEN_EXPIRED', 'No token found for user. Re-authenticate at /oauth/start', false);
        const client = new BasecampClient({ accessToken: record.accessToken, accountId: record.accountId });
        const raw = await client.get<Record<string, unknown>>(
          `buckets/${project_id}/todos/${todo_id}.json`
        );
        const { htmlToMarkdown } = await import('../client/html-to-markdown.js');
        const { TodoSchema } = await import('../client/schemas/index.js');
        // Assignees are in raw['assignees'] as array
        const assignees = (raw['assignees'] as Array<{ name: string; email_address: string }> ?? [])
          .map((a) => ({ name: a.name, email: a.email_address }));
        const todo = TodoSchema.parse({
          id: raw['id'],
          title: raw['content'],  // Basecamp: "content" is the todo title text
          author: raw['creator'],
          created_at: raw['created_at'],
          updated_at: raw['updated_at'],
          url: raw['app_url'],
          content: htmlToMarkdown(raw['description'] as string),
          completed: raw['completed'],
          due_on: raw['due_on'] ?? null,
        });
        return toolSuccess({ ...todo, assignees });
      } catch (error) {
        return classifyError(error);
      }
    },
  );

  return server;
}
```

**Step 3 — Compile and verify:**

Run: `npx tsc --noEmit`

If there are import errors for `@modelcontextprotocol/sdk`, confirm the package installed in Step 1 of Task 1. The import path `@modelcontextprotocol/sdk/server/mcp.js` is the correct ESM path for McpServer in SDK v1.15.0+.

If zod v4 raises type errors on `z.enum().optional().default()` chains — zod v4 (installed as ^4.3.6) supports this pattern identically to v3 for these basic types.
  </action>
  <verify>
1. `npx tsc --noEmit` exits 0
2. `ls src/tools/` shows `errors.ts` and `tools.ts`
3. `grep -n "createTools\|McpServer\|server.tool" src/tools/tools.ts | head -20` shows tool registrations
4. `grep -n "toolError\|classifyError\|toolSuccess" src/tools/errors.ts` shows all three exports
5. `grep -c "server.tool(" src/tools/tools.ts` outputs `7` (seven tool registrations)
  </verify>
  <done>
src/tools/errors.ts exports toolError, toolSuccess, classifyError, ToolErrorCode. src/tools/tools.ts exports createTools() registering 7 tools on McpServer. tsc compiles clean. Seven tool registrations confirmed by grep.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `cat package.json | grep modelcontextprotocol` shows ^1.15.0
- `grep "getProject" src/client/BasecampClient.ts` returns a match
- `grep -c "server.tool(" src/tools/tools.ts` outputs 7
- `ls src/tools/` shows errors.ts and tools.ts
</verification>

<success_criteria>
1. @modelcontextprotocol/sdk ^1.15.0 installed in package.json
2. BasecampClient.getProject(projectId) method exists and returns typed project+dock JSON
3. src/tools/errors.ts: toolError(), toolSuccess(), classifyError(), ToolErrorCode type all exported
4. src/tools/tools.ts: createTools(userId, tokenStore) factory registers exactly 7 tools (list_projects, get_project_tools, list_messages, get_message, list_todolists, list_todos, get_todo) on an McpServer instance
5. TypeScript compiles clean (tsc --noEmit exits 0)
6. get_project_tools uses dock.find(d => d.name === 'message_board') — the correct dock.name field (NOT dock.type)
</success_criteria>

<output>
After completion, create `.planning/phases/03-mcp-tool-definitions/03-01-SUMMARY.md`
</output>
