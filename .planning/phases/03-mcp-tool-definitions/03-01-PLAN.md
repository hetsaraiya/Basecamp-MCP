---
phase: 03-mcp-tool-definitions
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - package-lock.json
  - src/client/BasecampClient.ts
  - src/client/schemas/project.ts
  - src/client/schemas/message.ts
  - src/client/schemas/todo.ts
  - src/tools/errors.ts
  - src/tools/tools.ts
autonomous: true
requirements:
  - FR-2.1
  - FR-2.2
  - FR-2.3
  - FR-2.4
  - FR-3.1
  - FR-3.2
  - FR-3.3
  - FR-3.4
  - FR-4.1
  - FR-4.2
  - FR-4.3
  - FR-4.4
  - FR-8.1
  - FR-8.2
  - FR-8.3
  - FR-8.4

must_haves:
  truths:
    - "list_projects returns all accessible Basecamp projects with id, name, description, status, and active dock tool types"
    - "get_project_tools returns message_board_id, todoset_id, vault_id, chat_id without requiring those IDs as agent inputs"
    - "list_messages, list_todolists, list_todos, get_todo all require only project_id (plus content-specific IDs) — never internal dock IDs"
    - "get_message returns body in markdown (no raw HTML)"
    - "list_messages response items include replies_count"
    - "list_todos and get_todo response items include completed_at and comments_count"
    - "list_projects response items include a tools array of active dock tool names"
    - "Any tool call with missing required input returns { isError: true, content: [{ type: 'text', text: '...' }] } with an error_code field"
  artifacts:
    - path: "src/tools/errors.ts"
      provides: "Typed MCP error builder — toolError(code, message, retryable)"
      exports: ["toolError", "ToolErrorCode"]
    - path: "src/tools/tools.ts"
      provides: "createTools() factory returning list_projects, get_project_tools, list_messages, get_message, list_todolists, list_todos, get_todo registered on McpServer"
      exports: ["createTools"]
    - path: "src/client/BasecampClient.ts"
      provides: "getProject(projectId) method returning raw project JSON with dock array"
      contains: "getProject"
    - path: "src/client/schemas/project.ts"
      provides: "ProjectSchema with tools field for active dock tool names"
      contains: "tools"
    - path: "src/client/schemas/message.ts"
      provides: "MessageSchema with replies_count field"
      contains: "replies_count"
    - path: "src/client/schemas/todo.ts"
      provides: "TodoSchema with completed_at and comments_count fields"
      contains: "completed_at"
  key_links:
    - from: "src/tools/tools.ts"
      to: "src/client/BasecampClient.ts"
      via: "createTools(userId, tokenStore) constructs BasecampClient from tokenStore.get(userId)"
      pattern: "tokenStore\\.get\\(userId\\)"
    - from: "src/tools/tools.ts"
      to: "src/tools/errors.ts"
      via: "all tool handlers call toolError() on catch"
      pattern: "toolError\\("
    - from: "get_project_tools handler"
      to: "BasecampClient.getProject()"
      via: "dock.find(d => d.name === 'message_board') etc. per decided dock.name field"
      pattern: "d\\.name === 'message_board'"
    - from: "listProjects() in BasecampClient"
      to: "ProjectSchema"
      via: "tools field mapped from dock array — filter enabled, map to name strings"
      pattern: "tools.*dock.*enabled.*map"
    - from: "listMessages() in BasecampClient"
      to: "MessageSchema"
      via: "replies_count mapped from raw comments_count field"
      pattern: "replies_count.*comments_count"
    - from: "listTodos() in BasecampClient"
      to: "TodoSchema"
      via: "completed_at and comments_count mapped from raw fields"
      pattern: "completed_at"
---

<objective>
Install MCP SDK, extend three schemas with missing fields, update BasecampClient field mappings to pass those fields, add getProject() to BasecampClient, create the typed error module, and implement the first 7 MCP tools (list_projects, get_project_tools, list_messages, get_message, list_todolists, list_todos, get_todo) via a createTools() factory.

Purpose: These 7 tools cover the core project navigation and content-reading workflows that agents need most. The createTools() factory pattern (decided in CRITICAL DECISIONS) allows Phase 4 to bind per-session user IDs without any tool-layer changes. Schema extensions ensure FR-2.3, FR-3.4, and FR-4.4 are achievable at runtime — without them the dock tools list, message reply counts, and todo completion timestamps are silently discarded before reaching the agent.

Output: src/tools/errors.ts, src/tools/tools.ts (7 tools), BasecampClient.getProject(), three schema files extended, @modelcontextprotocol/sdk installed
</objective>

<execution_context>
@/home/het/.claude/get-shit-done/workflows/execute-plan.md
@/home/het/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/client/BasecampClient.ts
@src/client/schemas/index.ts
@src/client/schemas/project.ts
@src/client/schemas/message.ts
@src/client/schemas/todo.ts
@src/client/paginate.ts
@src/auth/store.ts
@src/client/types.ts
@.planning/phases/02-api-client-infrastructure/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install MCP SDK, extend schemas, update field mappings, and add getProject()</name>
  <files>package.json, package-lock.json, src/client/schemas/project.ts, src/client/schemas/message.ts, src/client/schemas/todo.ts, src/client/BasecampClient.ts</files>
  <action>
**Step 1 — Install MCP SDK:**

Run: `npm install @modelcontextprotocol/sdk@^1.15.0`

This installs the MCP SDK at ^1.15.0 (NOT the stale ^1.6.x in ROADMAP.md stack line — ^1.15.0 is the minimum required for authInfo passthrough in StreamableHTTPServerTransport). Confirm it appears in package.json dependencies.

**Step 2 — Extend ProjectSchema (FR-2.3):**

In `src/client/schemas/project.ts`, add a `tools` field to `ProjectSchema`. The dock field is the source of truth for which tools are active in a project. Without this field, `list_projects` silently discards dock data and agents cannot determine which tool IDs are available.

Change `ProjectSchema` from:

```typescript
export const ProjectSchema = z.object({
  id: z.number(),
  title: z.string(),
  author: AuthorSchema,
  created_at: z.string(),
  updated_at: z.string(),
  url: z.string(),
  status: z.string(),
  description: z.string().default(''),
});
```

To:

```typescript
export const ProjectSchema = z.object({
  id: z.number(),
  title: z.string(),
  author: AuthorSchema,
  created_at: z.string(),
  updated_at: z.string(),
  url: z.string(),
  status: z.string(),
  description: z.string().default(''),
  tools: z.array(z.string()).optional().default([]),
});
```

**Step 3 — Extend MessageSchema (FR-3.4):**

In `src/client/schemas/message.ts`, add a `replies_count` field to `MessageSchema`. Without this field, the Basecamp `comments_count` value is never surfaced to the agent even though the raw API returns it.

Change `MessageSchema` from:

```typescript
export const MessageSchema = z.object({
  id: z.number(),
  title: z.string(),
  author: AuthorSchema,
  created_at: z.string(),
  updated_at: z.string(),
  url: z.string(),
  content: z.string(),
});
```

To:

```typescript
export const MessageSchema = z.object({
  id: z.number(),
  title: z.string(),
  author: AuthorSchema,
  created_at: z.string(),
  updated_at: z.string(),
  url: z.string(),
  content: z.string(),
  replies_count: z.number().optional().default(0),
});
```

**Step 4 — Extend TodoSchema (FR-4.4):**

In `src/client/schemas/todo.ts`, add `completed_at` and `comments_count` to `TodoSchema`. Without these fields, the get_todo handler cannot surface completion timestamps or comment counts — the Basecamp API returns both but they are discarded by the schema parse.

Change `TodoSchema` from:

```typescript
export const TodoSchema = z.object({
  id: z.number(),
  title: z.string(),
  author: AuthorSchema,
  created_at: z.string(),
  updated_at: z.string(),
  url: z.string(),
  content: z.string(),
  completed: z.boolean(),
  due_on: z.string().nullable(),
});
```

To:

```typescript
export const TodoSchema = z.object({
  id: z.number(),
  title: z.string(),
  author: AuthorSchema,
  created_at: z.string(),
  updated_at: z.string(),
  url: z.string(),
  content: z.string(),
  completed: z.boolean(),
  due_on: z.string().nullable(),
  completed_at: z.string().nullable().optional(),
  comments_count: z.number().optional().default(0),
});
```

**Step 5 — Update BasecampClient field mappings:**

In `src/client/BasecampClient.ts`, update three methods to pass the new fields through to their schemas.

a) Update `listProjects()` — add `tools` from the dock array:

```typescript
async listProjects(page = 1): Promise<PaginatedResult<Project>> {
  return paginate(this, 'projects.json', page, (raw) => {
    const r = raw as Record<string, unknown>;
    const dock = (r['dock'] as Array<{ name: string; enabled: boolean }> ?? []);
    return ProjectSchema.parse({
      id: r['id'],
      title: r['name'],
      author: r['creator'],
      created_at: r['created_at'],
      updated_at: r['updated_at'],
      url: r['app_url'],
      status: r['status'],
      description: r['description'] ?? '',
      tools: dock.filter((d) => d.enabled).map((d) => d.name),
    });
  });
}
```

b) Update `listMessages()` — add `replies_count` from `comments_count`:

```typescript
async listMessages(
  bucketId: number,
  boardId: number,
  page = 1,
): Promise<PaginatedResult<Message>> {
  const path = `buckets/${bucketId}/message_boards/${boardId}/messages.json`;
  return paginate(this, path, page, (raw) => {
    const r = raw as Record<string, unknown>;
    return MessageSchema.parse({
      id: r['id'],
      title: r['subject'],
      author: r['creator'],
      created_at: r['created_at'],
      updated_at: r['updated_at'],
      url: r['app_url'],
      content: htmlToMarkdown(r['content'] as string),
      replies_count: (r['comments_count'] as number) ?? 0,
    });
  });
}
```

c) Update `listTodos()` — add `completed_at` and `comments_count`:

```typescript
async listTodos(
  bucketId: number,
  todoListId: number,
  page = 1,
): Promise<PaginatedResult<Todo>> {
  const path = `buckets/${bucketId}/todolists/${todoListId}/todos.json`;
  return paginate(this, path, page, (raw) => {
    const r = raw as Record<string, unknown>;
    return TodoSchema.parse({
      id: r['id'],
      title: r['content'],            // Basecamp: "content" is the todo title text
      author: r['creator'],
      created_at: r['created_at'],
      updated_at: r['updated_at'],
      url: r['app_url'],
      content: htmlToMarkdown(r['description'] as string),  // description is HTML notes
      completed: r['completed'],
      due_on: r['due_on'] ?? null,
      completed_at: (r['completed_at'] as string | null) ?? null,
      comments_count: (r['comments_count'] as number) ?? 0,
    });
  });
}
```

**Step 6 — Add getProject() to BasecampClient:**

In `src/client/BasecampClient.ts`, add a new public method after the existing `listAttachments` method:

```typescript
/**
 * getProject — returns the raw Basecamp project JSON including the dock array.
 *
 * Used by MCP tools to resolve dock-internal IDs (message_board_id, todoset_id,
 * vault_id, chat_id) without requiring the agent to supply them (FR-2.4).
 *
 * The dock array items have shape: { id, title, name, enabled, position, url, app_url }
 * where `name` is the dock tool type key. Correct name values:
 *   'message_board', 'todoset', 'vault', 'chat', 'schedule', 'questionnaire'
 * NOT the Ruby class names ('Message::Board' etc.) — confirmed 2026-02-19.
 */
async getProject(projectId: number): Promise<{
  id: number;
  name: string;
  description: string;
  status: string;
  created_at: string;
  updated_at: string;
  dock: Array<{
    id: number;
    title: string;
    name: string;
    enabled: boolean;
    position: number;
    url: string;
    app_url: string;
  }>;
}> {
  return this.get(`projects/${projectId}.json`);
}
```

Note: `this.get<T>()` already handles rate limiting and concurrency. No additional wrapping needed.

**Step 7 — Verify TypeScript compiles:**

Run: `npx tsc --noEmit`

Fix any type errors before proceeding.
  </action>
  <verify>
1. `cat package.json | grep modelcontextprotocol` shows `"@modelcontextprotocol/sdk": "^1.15.0"` in dependencies
2. `npx tsc --noEmit` exits 0 with no errors
3. `grep -n "getProject" src/client/BasecampClient.ts` shows the new method
4. `grep "tools" src/client/schemas/project.ts` shows `tools: z.array(z.string())`
5. `grep "replies_count" src/client/schemas/message.ts` shows the new field
6. `grep "completed_at\|comments_count" src/client/schemas/todo.ts` shows both new fields
7. `grep "replies_count\|comments_count" src/client/BasecampClient.ts` shows mappings in listMessages and listTodos
  </verify>
  <done>
@modelcontextprotocol/sdk ^1.15.0 in package.json dependencies. ProjectSchema has tools field, listProjects() maps dock to tools array. MessageSchema has replies_count, listMessages() maps from comments_count. TodoSchema has completed_at and comments_count, listTodos() maps both. getProject() method on BasecampClient returns typed project+dock object. tsc compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create typed error module and createTools() factory with 7 tools</name>
  <files>src/tools/errors.ts, src/tools/tools.ts</files>
  <action>
**Step 1 — Create src/tools/errors.ts:**

```typescript
/**
 * errors.ts — Typed MCP error responses for all tool handlers.
 *
 * MCP tool errors are returned as successful MCP responses (not thrown)
 * with isError: true and a structured content block. This lets agents
 * read the error_code and decide whether to retry or surface to user.
 * (FR-8.3, FR-8.4)
 */

export type ToolErrorCode =
  | 'TOKEN_EXPIRED'
  | 'RATE_LIMITED'
  | 'NOT_FOUND'
  | 'TOOL_NOT_ENABLED'
  | 'PERMISSION_DENIED'
  | 'INVALID_INPUT';

export interface ToolErrorPayload {
  error_code: ToolErrorCode;
  message: string;
  retryable: boolean;
}

/**
 * toolError — builds a structured MCP error response envelope.
 *
 * Returns the shape expected by McpServer tool handlers:
 *   { isError: true, content: [{ type: 'text', text: JSON.stringify(payload) }] }
 */
export function toolError(
  code: ToolErrorCode,
  message: string,
  retryable = false,
): { isError: true; content: Array<{ type: 'text'; text: string }> } {
  const payload: ToolErrorPayload = { error_code: code, message, retryable };
  return {
    isError: true,
    content: [{ type: 'text', text: JSON.stringify(payload) }],
  };
}

/**
 * toolSuccess — wraps a plain object as a successful MCP content envelope.
 *
 * All tool handlers return content blocks with type 'text' containing JSON.
 */
export function toolSuccess(
  data: unknown,
): { content: Array<{ type: 'text'; text: string }> } {
  return {
    content: [{ type: 'text', text: JSON.stringify(data, null, 2) }],
  };
}

/**
 * classifyError — maps known error types to ToolErrorCode.
 *
 * Called in every tool handler's catch block to translate BasecampClient
 * errors (RateLimitError, TokenExpiredError, HTTP 404s) into typed codes.
 */
export function classifyError(error: unknown): ReturnType<typeof toolError> {
  if (error instanceof Error) {
    // TokenExpiredError from src/auth/store.ts
    if ('code' in error && (error as { code: string }).code === 'TOKEN_EXPIRED') {
      return toolError('TOKEN_EXPIRED', error.message, false);
    }
    // RateLimitError from src/client/types.ts
    if (error.constructor.name === 'RateLimitError') {
      return toolError('RATE_LIMITED', error.message, true);
    }
    // got HTTP errors — check statusCode
    if ('response' in error) {
      const resp = (error as { response: { statusCode: number } }).response;
      if (resp?.statusCode === 404) {
        return toolError('NOT_FOUND', error.message, false);
      }
      if (resp?.statusCode === 403) {
        return toolError('PERMISSION_DENIED', error.message, false);
      }
    }
  }
  return toolError('NOT_FOUND', String(error), false);
}
```

**Step 2 — Create src/tools/tools.ts:**

Use static imports at the top of the file for `htmlToMarkdown` and `MessageSchema`/`TodoSchema`. Do NOT use dynamic `await import(...)` inside handler bodies — dynamic imports can silently swallow module errors in catch blocks and are inconsistent with the rest of the file's import style.

```typescript
/**
 * tools.ts — createTools() factory for all Phase 3 MCP tools.
 *
 * Architecture decision (STATE.md 2026-02-19):
 *   createTools(userId, tokenStore) is called once per MCP session.
 *   Phase 3 uses BASECAMP_TEST_USER_ID env var; Phase 4 passes per-session userId.
 *   The McpServer instance is created inside this factory and returned for transport wiring.
 *
 * Tool pattern:
 *   1. Parse and validate inputs with zod (z.object inputSchema)
 *   2. Call tokenStore.get(userId) to obtain credentials
 *   3. Construct BasecampClient(credentials)
 *   4. Call the appropriate client method
 *   5. Return toolSuccess(result) or classifyError(error)
 *
 * Dock lookup pattern (FR-2.4, decided 2026-02-19):
 *   Tools that need internal Basecamp IDs call client.getProject(projectId)
 *   and find dock items by `name` field (NOT `type`). Values: 'message_board',
 *   'todoset', 'vault', 'chat'. A disabled dock item returns TOOL_NOT_ENABLED.
 */

import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';
import { BasecampClient } from '../client/BasecampClient.js';
import { TokenStore } from '../auth/store.js';
import { toolError, toolSuccess, classifyError } from './errors.js';
import { htmlToMarkdown } from '../client/html-to-markdown.js';
import { MessageSchema, TodoSchema } from '../client/schemas/index.js';

// ---------------------------------------------------------------------------
// Dock lookup helper
// ---------------------------------------------------------------------------

/**
 * findDockItem — resolves a dock tool's internal Basecamp ID from the project dock.
 *
 * Returns { id, url } for the dock item with the given name, or null if not found
 * or not enabled. Callers check for null and return TOOL_NOT_ENABLED.
 *
 * dock.name values: 'message_board', 'todoset', 'vault', 'chat'
 */
function findDockItem(
  dock: Array<{ id: number; name: string; enabled: boolean; url: string }>,
  name: string,
): { id: number; url: string } | null {
  const item = dock.find((d) => d.name === name);
  if (!item || !item.enabled) return null;
  return { id: item.id, url: item.url };
}

// ---------------------------------------------------------------------------
// Factory
// ---------------------------------------------------------------------------

export function createTools(userId: number, tokenStore: TokenStore): McpServer {
  const server = new McpServer({
    name: 'basecamp-mcp',
    version: '1.0.0',
  });

  // -------------------------------------------------------------------------
  // list_projects — FR-2.1, FR-2.2, FR-2.3
  // -------------------------------------------------------------------------
  server.tool(
    'list_projects',
    'List all Basecamp projects accessible to the authenticated user. Returns project IDs, names, descriptions, statuses, and which tools (messages, todos, docs, campfire) are active in each project. Use project_id from results to call other tools.',
    {
      status: z.enum(['active', 'archived', 'all']).optional().default('active').describe(
        'Filter by project status. "active" (default) returns only active projects. "archived" returns archived only. "all" returns both.'
      ),
      page: z.number().int().positive().optional().default(1).describe(
        'Page number for pagination. Check has_more in response to determine if more pages exist.'
      ),
    },
    async ({ status, page }) => {
      try {
        const record = tokenStore.get(userId);
        if (!record) return toolError('TOKEN_EXPIRED', 'No token found for user. Re-authenticate at /oauth/start', false);
        const client = new BasecampClient({ accessToken: record.accessToken, accountId: record.accountId });
        const result = await client.listProjects(page);
        // Apply status filter (Basecamp API returns all statuses, we filter client-side for 'active'/'archived')
        const items = status === 'all'
          ? result.items
          : result.items.filter((p) => p.status === (status === 'active' ? 'active' : 'archived'));
        return toolSuccess({ ...result, items });
      } catch (error) {
        return classifyError(error);
      }
    },
  );

  // -------------------------------------------------------------------------
  // get_project_tools — FR-2.4
  // -------------------------------------------------------------------------
  server.tool(
    'get_project_tools',
    'Get the internal tool IDs for a Basecamp project. Returns message_board_id, todoset_id, vault_id, and chat_id needed to call content tools. Also shows which tools are currently enabled. Always call this before calling list_messages, list_todolists, list_documents, or list_campfire_lines for a project you have not queried before.',
    {
      project_id: z.number().int().positive().describe('The Basecamp project ID from list_projects'),
    },
    async ({ project_id }) => {
      try {
        const record = tokenStore.get(userId);
        if (!record) return toolError('TOKEN_EXPIRED', 'No token found for user. Re-authenticate at /oauth/start', false);
        const client = new BasecampClient({ accessToken: record.accessToken, accountId: record.accountId });
        const project = await client.getProject(project_id);
        // Build a clean map of dock tool names → their IDs and enabled status
        const tools: Record<string, { id: number; enabled: boolean; url: string }> = {};
        for (const item of project.dock) {
          tools[item.name] = { id: item.id, enabled: item.enabled, url: item.app_url };
        }
        return toolSuccess({
          project_id: project.id,
          project_name: project.name,
          message_board_id: tools['message_board']?.id ?? null,
          todoset_id: tools['todoset']?.id ?? null,
          vault_id: tools['vault']?.id ?? null,
          chat_id: tools['chat']?.id ?? null,
          tools,
        });
      } catch (error) {
        return classifyError(error);
      }
    },
  );

  // -------------------------------------------------------------------------
  // list_messages — FR-3.1, FR-3.3, FR-3.4
  // -------------------------------------------------------------------------
  server.tool(
    'list_messages',
    'List message board posts in a Basecamp project. Returns message subjects, authors, creation dates, content as markdown, and replies_count. Get message_board_id from get_project_tools first.',
    {
      project_id: z.number().int().positive().describe('The Basecamp project ID'),
      message_board_id: z.number().int().positive().describe('The message board ID from get_project_tools'),
      page: z.number().int().positive().optional().default(1).describe('Page number for pagination'),
    },
    async ({ project_id, message_board_id, page }) => {
      try {
        const record = tokenStore.get(userId);
        if (!record) return toolError('TOKEN_EXPIRED', 'No token found for user. Re-authenticate at /oauth/start', false);
        const client = new BasecampClient({ accessToken: record.accessToken, accountId: record.accountId });
        const result = await client.listMessages(project_id, message_board_id, page);
        return toolSuccess(result);
      } catch (error) {
        return classifyError(error);
      }
    },
  );

  // -------------------------------------------------------------------------
  // get_message — FR-3.2, FR-3.3, FR-3.4
  // -------------------------------------------------------------------------
  server.tool(
    'get_message',
    'Get a single Basecamp message board post with full content as markdown. Returns the message subject, author (name and email), creation date, and the full post body converted to markdown. Use message IDs from list_messages.',
    {
      project_id: z.number().int().positive().describe('The Basecamp project ID'),
      message_id: z.number().int().positive().describe('The message ID from list_messages'),
    },
    async ({ project_id, message_id }) => {
      try {
        const record = tokenStore.get(userId);
        if (!record) return toolError('TOKEN_EXPIRED', 'No token found for user. Re-authenticate at /oauth/start', false);
        const client = new BasecampClient({ accessToken: record.accessToken, accountId: record.accountId });
        // get_message fetches a single message — no paginate, direct GET
        const raw = await client.get<Record<string, unknown>>(
          `buckets/${project_id}/messages/${message_id}.json`
        );
        const message = MessageSchema.parse({
          id: raw['id'],
          title: raw['subject'],
          author: raw['creator'],
          created_at: raw['created_at'],
          updated_at: raw['updated_at'],
          url: raw['app_url'],
          content: htmlToMarkdown(raw['content'] as string),
          replies_count: (raw['comments_count'] as number) ?? 0,
        });
        return toolSuccess(message);
      } catch (error) {
        return classifyError(error);
      }
    },
  );

  // -------------------------------------------------------------------------
  // list_todolists — FR-4.1
  // -------------------------------------------------------------------------
  server.tool(
    'list_todolists',
    'List to-do lists in a Basecamp project. Returns list names, descriptions, and item counts. Get todoset_id from get_project_tools first. Use todolist IDs from results to call list_todos.',
    {
      project_id: z.number().int().positive().describe('The Basecamp project ID'),
      todoset_id: z.number().int().positive().describe('The todoset ID from get_project_tools'),
      page: z.number().int().positive().optional().default(1).describe('Page number for pagination'),
    },
    async ({ project_id, todoset_id, page }) => {
      try {
        const record = tokenStore.get(userId);
        if (!record) return toolError('TOKEN_EXPIRED', 'No token found for user. Re-authenticate at /oauth/start', false);
        const client = new BasecampClient({ accessToken: record.accessToken, accountId: record.accountId });
        const result = await client.listTodoLists(project_id, todoset_id, page);
        return toolSuccess(result);
      } catch (error) {
        return classifyError(error);
      }
    },
  );

  // -------------------------------------------------------------------------
  // list_todos — FR-4.2, FR-4.4
  // -------------------------------------------------------------------------
  server.tool(
    'list_todos',
    'List to-do items in a specific to-do list. Returns todo titles, descriptions as markdown, assignees, due dates, completion status, completed_at timestamp, and comments_count. Use todolist_id from list_todolists.',
    {
      project_id: z.number().int().positive().describe('The Basecamp project ID'),
      todolist_id: z.number().int().positive().describe('The to-do list ID from list_todolists'),
      completed: z.boolean().optional().default(false).describe(
        'If false (default), returns only incomplete todos. If true, returns completed todos.'
      ),
      page: z.number().int().positive().optional().default(1).describe('Page number for pagination'),
    },
    async ({ project_id, todolist_id, completed, page }) => {
      try {
        const record = tokenStore.get(userId);
        if (!record) return toolError('TOKEN_EXPIRED', 'No token found for user. Re-authenticate at /oauth/start', false);
        const client = new BasecampClient({ accessToken: record.accessToken, accountId: record.accountId });
        // listTodos fetches all todos; filter by completed status client-side
        const result = await client.listTodos(project_id, todolist_id, page);
        const items = result.items.filter((t) => t.completed === completed);
        return toolSuccess({ ...result, items });
      } catch (error) {
        return classifyError(error);
      }
    },
  );

  // -------------------------------------------------------------------------
  // get_todo — FR-4.3, FR-4.4
  // -------------------------------------------------------------------------
  server.tool(
    'get_todo',
    'Get a single Basecamp to-do item with full detail. Returns the todo title, description as markdown, assignees with names and emails, due date, completion status, completed_at timestamp, comments_count, and creation date.',
    {
      project_id: z.number().int().positive().describe('The Basecamp project ID'),
      todo_id: z.number().int().positive().describe('The to-do item ID from list_todos'),
    },
    async ({ project_id, todo_id }) => {
      try {
        const record = tokenStore.get(userId);
        if (!record) return toolError('TOKEN_EXPIRED', 'No token found for user. Re-authenticate at /oauth/start', false);
        const client = new BasecampClient({ accessToken: record.accessToken, accountId: record.accountId });
        const raw = await client.get<Record<string, unknown>>(
          `buckets/${project_id}/todos/${todo_id}.json`
        );
        // Assignees are in raw['assignees'] as array
        const assignees = (raw['assignees'] as Array<{ name: string; email_address: string }> ?? [])
          .map((a) => ({ name: a.name, email: a.email_address }));
        const todo = TodoSchema.parse({
          id: raw['id'],
          title: raw['content'],  // Basecamp: "content" is the todo title text
          author: raw['creator'],
          created_at: raw['created_at'],
          updated_at: raw['updated_at'],
          url: raw['app_url'],
          content: htmlToMarkdown(raw['description'] as string),
          completed: raw['completed'],
          due_on: raw['due_on'] ?? null,
          completed_at: (raw['completed_at'] as string | null) ?? null,
          comments_count: (raw['comments_count'] as number) ?? 0,
        });
        return toolSuccess({ ...todo, assignees });
      } catch (error) {
        return classifyError(error);
      }
    },
  );

  return server;
}
```

**Step 3 — Compile and verify:**

Run: `npx tsc --noEmit`

If there are import errors for `@modelcontextprotocol/sdk`, confirm the package installed in Step 1 of Task 1. The import path `@modelcontextprotocol/sdk/server/mcp.js` is the correct ESM path for McpServer in SDK v1.15.0+.

If zod v4 raises type errors on `z.enum().optional().default()` chains — zod v4 (installed as ^4.3.6) supports this pattern identically to v3 for these basic types.
  </action>
  <verify>
1. `npx tsc --noEmit` exits 0
2. `ls src/tools/` shows `errors.ts` and `tools.ts`
3. `grep -n "createTools\|McpServer\|server.tool" src/tools/tools.ts | head -20` shows tool registrations
4. `grep -n "toolError\|classifyError\|toolSuccess" src/tools/errors.ts` shows all three exports
5. `grep -c "server.tool(" src/tools/tools.ts` outputs `7` (seven tool registrations)
6. `grep "^import" src/tools/tools.ts | grep -v "await import"` — no dynamic imports remain in the file; htmlToMarkdown and MessageSchema/TodoSchema are top-level static imports
  </verify>
  <done>
src/tools/errors.ts exports toolError, toolSuccess, classifyError, ToolErrorCode. src/tools/tools.ts exports createTools() registering 7 tools on McpServer. All schema imports (htmlToMarkdown, MessageSchema, TodoSchema) are static top-level imports — no dynamic await import() calls. tsc compiles clean. Seven tool registrations confirmed by grep.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `cat package.json | grep modelcontextprotocol` shows ^1.15.0
- `grep "getProject" src/client/BasecampClient.ts` returns a match
- `grep -c "server.tool(" src/tools/tools.ts` outputs 7
- `ls src/tools/` shows errors.ts and tools.ts
- `grep "tools" src/client/schemas/project.ts` shows tools field in ProjectSchema
- `grep "replies_count" src/client/schemas/message.ts` shows field present
- `grep "completed_at\|comments_count" src/client/schemas/todo.ts` shows both fields
- `grep "^import" src/tools/tools.ts` — htmlToMarkdown, MessageSchema, TodoSchema all imported at top level (no await import)
- `grep "dock.*enabled.*map\|tools.*dock" src/client/BasecampClient.ts` shows dock-to-tools mapping in listProjects
- `grep "replies_count\|comments_count" src/client/BasecampClient.ts` shows mappings in listMessages and listTodos
</verification>

<success_criteria>
1. @modelcontextprotocol/sdk ^1.15.0 installed in package.json
2. ProjectSchema has `tools: z.array(z.string()).optional().default([])` — listProjects() maps from dock array filtering enabled items
3. MessageSchema has `replies_count: z.number().optional().default(0)` — listMessages() maps from raw `comments_count`
4. TodoSchema has `completed_at: z.string().nullable().optional()` and `comments_count: z.number().optional().default(0)` — listTodos() maps both; get_todo handler passes both in TodoSchema.parse()
5. BasecampClient.getProject(projectId) method exists and returns typed project+dock JSON
6. src/tools/errors.ts: toolError(), toolSuccess(), classifyError(), ToolErrorCode type all exported
7. src/tools/tools.ts: createTools(userId, tokenStore) factory registers exactly 7 tools on McpServer
8. tools.ts uses static imports for htmlToMarkdown, MessageSchema, TodoSchema — no dynamic await import() calls
9. TypeScript compiles clean (tsc --noEmit exits 0)
10. get_project_tools uses dock.find(d => d.name === 'message_board') — the correct dock.name field (NOT dock.type)
</success_criteria>

<output>
After completion, create `.planning/phases/03-mcp-tool-definitions/03-01-SUMMARY.md`
</output>
